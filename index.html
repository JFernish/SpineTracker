<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Spine Token Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            padding: 20px;
            color: #e0e0e0;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(20, 20, 40, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(157, 78, 221, 0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #ffffff;
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #9d4edd, #6a4c93, #3a86ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(157, 78, 221, 0.3);
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .btn {
            background: linear-gradient(45deg, #6a4c93, #9d4edd);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(157, 78, 221, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(157, 78, 221, 0.4);
            background: linear-gradient(45deg, #9d4edd, #3a86ff);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn.success {
            background: linear-gradient(45deg, #06ffa5, #00cc88);
            box-shadow: 0 4px 15px rgba(6, 255, 165, 0.3);
        }
        
        .btn.discover {
            background: linear-gradient(45deg, #3a86ff, #06ffa5);
            box-shadow: 0 4px 15px rgba(58, 134, 255, 0.3);
        }
        
        .status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .status.connected {
            background: rgba(6, 255, 165, 0.2);
            color: #06ffa5;
            border: 1px solid rgba(6, 255, 165, 0.3);
        }
        
        .status.error {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }
        
        .status.loading {
            background: rgba(157, 78, 221, 0.2);
            color: #9d4edd;
            border: 1px solid rgba(157, 78, 221, 0.3);
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .config-section {
            background: rgba(102, 126, 234, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 25px;
            border: 2px solid rgba(102, 126, 234, 0.2);
        }
        
        .config-title {
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }
        
        .config-item {
            display: inline-block;
            margin-right: 20px;
            margin-bottom: 10px;
        }
        
        .config-item label {
            font-size: 0.9rem;
            color: #c0c0c0;
            font-weight: 500;
            margin-right: 10px;
        }
        
        .config-item input {
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            font-size: 0.9rem;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            width: 400px;
        }
        
        .config-item input::placeholder {
            color: #888;
        }
        
        .discovery-log {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #c0c0c0;
        }
        
        .table-container {
            overflow-x: auto;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(30, 30, 60, 0.8);
            font-size: 0.85rem;
            border-radius: 15px;
            overflow: hidden;
        }
        
        th {
            background: linear-gradient(45deg, #6a4c93, #9d4edd);
            color: white;
            padding: 12px 8px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            font-size: 0.8rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        td {
            padding: 10px 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background-color 0.3s ease;
            color: #e0e0e0;
        }
        
        tr:hover {
            background-color: rgba(157, 78, 221, 0.1);
        }
        
        .parent-row {
            background: rgba(6, 255, 165, 0.2);
            border-left: 4px solid #06ffa5;
            font-weight: 600;
        }
        
        .child-row {
            background: rgba(157, 78, 221, 0.1);
            border-left: 4px solid #9d4edd;
        }
        
        .token-name {
            font-weight: 600;
            color: #ffffff;
        }
        
        .address {
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            color: #90a4ae;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        
        .address:hover {
            color: #9d4edd;
        }
        
        .price {
            font-weight: 600;
            color: #06ffa5;
            font-family: 'Courier New', monospace;
            text-align: right;
        }
        
        .price.negative {
            color: #f44336;
        }
        
        .parity {
            font-weight: 600;
            font-family: 'Courier New', monospace;
            text-align: right;
            font-size: 0.9rem;
        }
        
        .parity.profitable {
            color: #06ffa5;
        }
        
        .parity.unprofitable {
            color: #f44336;
        }
        
        .multiplier {
            background: linear-gradient(45deg, #3a86ff, #6a4c93);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: 600;
            text-align: right;
            min-width: 60px;
            font-size: 0.8rem;
            font-family: 'Courier New', monospace;
            box-shadow: 0 2px 8px rgba(58, 134, 255, 0.3);
            display: inline-block;
        }
        
        .loading-cell {
            text-align: center;
            color: #90a4ae;
            font-style: italic;
        }
        
        .price-source {
            font-size: 0.7rem;
            color: #888;
            font-style: italic;
        }
        
        .mint-btn {
            background: linear-gradient(45deg, #3a86ff, #06ffa5);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(58, 134, 255, 0.3);
        }
        
        .mint-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(58, 134, 255, 0.4);
        }
        
        .total-multiplier-section {
            background: rgba(157, 78, 221, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 2px solid rgba(157, 78, 221, 0.2);
            text-align: left;
        }
        
        .total-multiplier-title {
            color: #ffffff;
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .footer {
            text-align: center;
            margin-top: 30px;
            color: #90a4ae;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            table {
                font-size: 0.75rem;
            }
            
            th, td {
                padding: 6px 4px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Dynamic Spine Token Tracker</h1>
            <p>Automatically discover V4 factory token spines by walking up from any child token</p>
            <div style="background: rgba(157, 78, 221, 0.1); padding: 15px; border-radius: 10px; margin-top: 15px; border: 2px solid rgba(157, 78, 221, 0.2);">
                <strong>⚠️ Entertainment Purposes Only:</strong> This tool is for entertainment purposes. All data should be independently verified before making any financial decisions. Always DYOR (Do Your Own Research).
            </div>
        </div>
        
        <div class="config-section">
            <div class="config-title">
                🔧 Configuration
                <button onclick="toggleDiscoveryLog()" id="logToggleBtn" style="float: right; background: rgba(157, 78, 221, 0.3); border: 1px solid rgba(157, 78, 221, 0.5); color: #9d4edd; padding: 4px 8px; border-radius: 6px; font-size: 0.8rem; cursor: pointer;">
                    📄 Hide Log
                </button>
            </div>
            <div class="config-item">
                <label>RPC URL:</label>
                <input type="text" id="rpcUrl" value="https://rpc-pulsechain.g4mm4.io">
            </div>
            <div class="config-item">
                <label>Starting V4 Token Address (lowest child):</label>
                <input type="text" id="startingToken" value="0x7e264cd4fa2354078f527f6a72afbadc0ba89d26" placeholder="0x...">
            </div>
            <div class="config-item">
                <label>Auto-refresh interval (seconds):</label>
                <input type="number" id="refreshInterval" value="300" min="10" max="600" style="width: 100px;">
            </div>
            
            <div class="discovery-log" id="discoveryLog" style="max-height: 100px;">
                Ready to discover V4 token spine... Enter a V4 child token address and click "Discover V4 Spine"
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <button class="btn" onclick="testConnection()" id="testBtn">
                    🔗 Test Connection
                </button>
                <button class="btn discover" onclick="discoverSpine()" id="discoverBtn">
                    🧬 Discover V4 Spine
                </button>
                <button class="btn" onclick="refreshData()" id="refreshBtn" disabled>
                    🔄 Refresh Data
                </button>
                <button class="btn" onclick="toggleAutoRefresh()" id="autoRefreshBtn">
                    ⏰ Auto-Refresh: OFF
                </button>
            </div>
            
            <div class="control-group">
                <div class="status" id="status">
                    <div class="status-dot"></div>
                    <span>Ready to connect</span>
                </div>
                <div style="font-size: 0.8rem; color: #90a4ae;" id="lastUpdate">
                    Last updated: Never
                </div>
            </div>
        </div>
        
        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Position</th>
                        <th>Token Name</th>
                        <th>Contract Address</th>
                        <th>Total Supply</th>
                        <th>Multiplier</th>
                        <th>Price (USD)</th>
                        <th>Parity %</th>
                        <th style="width: 60px;">Mint</th>
                    </tr>
                </thead>
                <tbody id="tokenTable">
                    <tr>
                        <td colspan="8" style="text-align: center; padding: 40px; color: #90a4ae;">
                            No V4 tokens discovered yet. Click "Discover V4 Spine" to start building the spine from a V4 child token.
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <!-- Total Multiplier Section -->
        <div class="total-multiplier-section" id="totalMultiplierSection" style="display: none;">
            <div class="total-multiplier-title">📊 Spine Summary</div>
            <p style="margin: 10px 0; font-size: 1rem; line-height: 1.5;">
                <strong>Total Spine Multiplier:</strong> <span class="total-multiplier-value" id="totalMultiplierValue" style="color: #06ffa5; font-family: 'Courier New', monospace; font-weight: 700;">-</span>
                <span style="font-size: 0.9rem; color: #c0c0c0;"> (aggregate of all child multipliers)</span>
            </p>
            <p style="margin: 10px 0; font-size: 1rem; line-height: 1.5;">
                <strong>Implied Lowest Child Price at Parity:</strong> $<span class="implied-price-value" id="impliedPriceValue" style="color: #3a86ff; font-family: 'Courier New', monospace; font-weight: 700;">-</span>
                <span style="font-size: 0.9rem; color: #c0c0c0;"> (parent price × total multiplier)</span>
            </p>
        </div>
        
        <div class="footer">
            <p><strong>Instructions:</strong> 1) Enter any V4 child token address → 2) Click "Discover V4 Spine" → 3) Click "Refresh Data" to load prices/multipliers</p>
            <p><strong>Price Colors:</strong> Green = 24h price increase, Red = 24h price decrease</p>
            <p><strong>Parity %:</strong> Shows minting opportunity - Green >100% = profitable to mint child, Red <100% = profitable to buy child (assuming price will return to parity)</p>
            <p><strong>Parity Calculation:</strong> Child Price ÷ (Parent Price × Multiplier) × 100%</p>
            <p><strong>Enhanced Pricing:</strong> Prioritizes PLS pairs → USDC/USDT → ETH pairs for maximum accuracy</p>
            <p><strong>Note:</strong> This tool only works with tokens created from the V4 factory. Please avoid using auto-refresh to limit RPC calls and be respectful of the infrastructure</p>
            <p><strong>Chain:</strong> PulseChain (Chain ID: 369) | <strong>RPC:</strong> G4mm4.io</p>
            
            <div style="margin-top: 30px; padding: 20px; background: rgba(157, 78, 221, 0.1); border-radius: 15px; border: 2px solid rgba(157, 78, 221, 0.2); text-align: left;">
                <p style="margin-bottom: 15px;"><strong>🎯 Multi-Hop Minting Available:</strong> Multi-hop minting is accessible from the Mint pages and allows you to mint directly from any parent token in a spine to any child token in a single transaction, skipping intermediate steps. One click, multiple hops.</p>
                <p style="margin-bottom: 15px;">The provided information may not be 100% accurate and still needs some testing.</p>
                <p style="margin-bottom: 10px;"><strong>Your support is greatly appreciated and helps me continue improving the website.</strong></p>
                <p style="font-family: 'Courier New', monospace; background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 8px; margin: 10px 0; word-break: break-all; font-size: 0.85rem;">0x809b15CCdC92882035C274738318296525b98aD8</p>
                
                <p style="margin-top: 20px; margin-bottom: 10px;"><strong>Disclaimer:</strong></p>
                <p style="margin-bottom: 10px; font-size: 0.9rem; line-height: 1.4;">All content provided on this site is for informational purposes only and does not constitute financial advice. None of the information presented here should be considered as investment advice or a recommendation to buy, sell, or hold any financial product or instrument.</p>
                
                <p style="margin-bottom: 10px; font-size: 0.9rem; line-height: 1.4;">Please perform your own research and consult with a qualified financial advisor before making any investment decisions. We do not take responsibility for any financial losses you may incur as a result of using the information provided on this site.</p>
                
                <p style="margin-bottom: 0; font-size: 0.9rem; line-height: 1.4;">Remember, all investments carry risk, and past performance is not indicative of future results.</p>
            </div>
        </div>
    </div>

    <script>
        // Discovered tokens will be stored here
        let discoveredTokens = [];
        let tokenMultipliers = new Map(); // Store multipliers for multi-hop
        let autoRefreshInterval = null;
        let isAutoRefreshing = false;
        
        // Price cache to avoid hammering APIs
        const priceCache = new Map();
        const CACHE_DURATION = 60000; // 1 minute

        // RPC call function
        async function makeRPCCall(method, params = []) {
            const rpcUrl = document.getElementById('rpcUrl').value;
            
            const response = await fetch(rpcUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    method: method,
                    params: params,
                    id: Date.now()
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            if (data.error) {
                throw new Error(`RPC Error: ${data.error.message}`);
            }
            
            return data.result;
        }

        // Status and logging functions
        function setStatus(message, type = 'loading') {
            const status = document.getElementById('status');
            status.className = `status ${type}`;
            status.querySelector('span').textContent = message;
        }

        function logDiscovery(message) {
            const log = document.getElementById('discoveryLog');
            const timestamp = new Date().toLocaleTimeString();
            log.textContent += `\n[${timestamp}] ${message}`;
            log.scrollTop = log.scrollHeight;
        }

        // Format price with commas for readability
        function formatPrice(price) {
            if (price < 1) {
                return price.toFixed(5);
            } else {
                return price.toLocaleString('en-US', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            }
        }

        // Simplified pricing function (removed stable pair checking)
        async function getPulseXPriceWithHierarchy(tokenAddress) {
            console.log(`🔍 Getting price for ${tokenAddress}...`);
            
            // Check cache first
            const cacheKey = `price_${tokenAddress.toLowerCase()}`;
            const cached = priceCache.get(cacheKey);
            if (cached && (Date.now() - cached.timestamp) < CACHE_DURATION) {
                console.log(`📋 Using cached price for ${tokenAddress}`);
                return cached.data;
            }
            
            // Simplified pricing sources - PLS pairs first, then USD
            const pricingSources = [
                { name: 'GeckoTerminal_PLS', priority: 1 },
                { name: 'GeckoTerminal_USD', priority: 2 },
                { name: 'DexScreener', priority: 3 }
            ];

            // Try each pricing source in order
            for (const source of pricingSources) {
                try {
                    console.log(`💰 Trying ${source.name}...`);
                    
                    let priceData = null;
                    
                    if (source.name.startsWith('GeckoTerminal')) {
                        priceData = await getGeckoTerminalPrice(tokenAddress, source.name === 'GeckoTerminal_PLS');
                    } else if (source.name === 'DexScreener') {
                        priceData = await getDexScreenerPrice(tokenAddress);
                    }
                    
                    if (priceData && priceData.price > 0) {
                        console.log(`✅ Got price from ${source.name}: ${priceData.price}`);
                        priceData.source = source.name;
                        priceData.priority = source.priority;
                        
                        // Cache the result
                        priceCache.set(cacheKey, {
                            data: priceData,
                            timestamp: Date.now()
                        });
                        
                        return priceData;
                    }
                    
                } catch (error) {
                    console.log(`❌ ${source.name} failed: ${error.message}`);
                    continue;
                }
            }
            
            // Fallback
            console.log(`⚠️ All pricing sources failed, using fallback data`);
            return getFallbackPriceData(tokenAddress);
        }

        // Simplified GeckoTerminal function
        async function getGeckoTerminalPrice(tokenAddress, preferPLSPairs = false) {
            const pulseChainId = 'pulsechain';
            const url = `https://api.geckoterminal.com/api/v2/networks/${pulseChainId}/tokens/${tokenAddress.toLowerCase()}`;
            
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`GeckoTerminal API: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.data && data.data.attributes) {
                const attrs = data.data.attributes;
                let pairInfo = 'USD price';
                
                // If we prefer PLS pairs, try to get PLS-denominated price first
                if (preferPLSPairs && data.included) {
                    const plsPairs = data.included.filter(item => 
                        item.type === 'pool' && 
                        (item.attributes.base_token_name?.toLowerCase().includes('pls') ||
                         item.attributes.quote_token_name?.toLowerCase().includes('pls'))
                    );
                    
                    if (plsPairs.length > 0) {
                        console.log(`🎯 Found ${plsPairs.length} PLS pairs`);
                        pairInfo = 'PLS pair';
                    }
                }
                
                return {
                    price: parseFloat(attrs.price_usd || '0'),
                    volume24h: parseFloat(attrs.volume_usd?.h24 || '0'),
                    priceChange24h: parseFloat(attrs.price_change_percentage?.h24 || '0'),
                    pairInfo: pairInfo
                };
            }
            
            throw new Error('No price data in GeckoTerminal response');
        }

        // Simplified DexScreener function
        async function getDexScreenerPrice(tokenAddress) {
            const url = `https://api.dexscreener.com/latest/dex/tokens/${tokenAddress}`;
            
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`DexScreener API: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.pairs && data.pairs.length > 0) {
                // Get highest liquidity pair
                const selectedPair = data.pairs.sort((a, b) => 
                    parseFloat(b.liquidity?.usd || '0') - parseFloat(a.liquidity?.usd || '0')
                )[0];
                
                if (selectedPair) {
                    return {
                        price: parseFloat(selectedPair.priceUsd || '0'),
                        volume24h: parseFloat(selectedPair.volume?.h24 || '0'),
                        priceChange24h: parseFloat(selectedPair.priceChange?.h24 || '0'),
                        pairInfo: `${selectedPair.baseToken?.symbol}/${selectedPair.quoteToken?.symbol}`
                    };
                }
            }
            
            throw new Error('No suitable pairs found on DexScreener');
        }

        // Fallback price data generator
        function getFallbackPriceData(tokenAddress) {
            return {
                price: 0,
                volume24h: 0,
                priceChange24h: 0,
                source: 'No pricing data available',
                priority: 999,
                pairInfo: 'No pairs found'
            };
        }

        function hexToString(hex) {
            let result = '';
            for (let i = 0; i < hex.length; i += 2) {
                const byte = parseInt(hex.substr(i, 2), 16);
                if (byte !== 0) { // Skip null bytes
                    result += String.fromCharCode(byte);
                }
            }
            return result.replace(/[^\x20-\x7E]/g, ''); // Remove non-printable characters
        }

        // Get token symbol from contract (shorter identifier)
        async function getTokenSymbol(address) {
            console.log(`🔍 getTokenSymbol called for ${address}`);
            
            try {
                console.log(`🔍 Getting symbol from contract for ${address}...`);
                
                const symbolResult = await makeRPCCall('eth_call', [
                    {
                        to: address,
                        data: '0x95d89b41'
                    },
                    'latest'
                ]);
                
                console.log(`📥 Symbol result for ${address}: ${symbolResult}`);
                
                if (symbolResult && symbolResult !== '0x') {
                    const hex = symbolResult.slice(2);
                    console.log(`🔤 Processing hex: ${hex}`);
                    
                    if (hex.length >= 64) {
                        // Try different decoding approaches
                        
                        // Approach 1: Standard ABI encoding
                        if (hex.length >= 128) {
                            try {
                                console.log(`🧪 Trying standard ABI decoding...`);
                                const lengthHex = hex.substring(64, 128);
                                const length = parseInt(lengthHex, 16);
                                console.log(`📐 Decoded length: ${length}`);
                                if (length > 0 && length < 100) {
                                    const symbolHex = hex.substring(128, 128 + (length * 2));
                                    console.log(`🔤 Symbol hex: ${symbolHex}`);
                                    const symbol = hexToString(symbolHex);
                                    console.log(`✨ Decoded symbol: "${symbol}"`);
                                    if (symbol && symbol.length > 0 && /^[\w\u3000-\u9FFF㉾]+$/.test(symbol)) {
                                        console.log(`✅ Symbol decoded (standard): ${symbol}`);
                                        return symbol;
                                    }
                                }
                            } catch (e) {
                                console.log('❌ Standard ABI decoding failed:', e.message);
                            }
                        }
                        
                        // Approach 2: Direct hex to string
                        try {
                            console.log(`🧪 Trying direct hex decoding...`);
                            const cleanHex = hex.replace(/^0+/, '');
                            console.log(`🧹 Clean hex: ${cleanHex}`);
                            if (cleanHex.length > 0 && cleanHex.length <= 64) {
                                const directSymbol = hexToString(cleanHex);
                                console.log(`✨ Direct decoded: "${directSymbol}"`);
                                if (directSymbol && /^[\w\u3000-\u9FFF㉾]+$/.test(directSymbol) && directSymbol.length <= 10) {
                                    console.log(`✅ Symbol decoded (direct): ${directSymbol}`);
                                    return directSymbol;
                                }
                            }
                        } catch (e) {
                            console.log('❌ Direct hex decoding failed:', e.message);
                        }
                        
                        // Approach 3: Try last 32 bytes
                        try {
                            console.log(`🧪 Trying last part decoding...`);
                            const lastPart = hex.slice(-64);
                            console.log(`🔚 Last part: ${lastPart}`);
                            const lastSymbol = hexToString(lastPart);
                            console.log(`✨ Last decoded: "${lastSymbol}"`);
                            if (lastSymbol && /^[\w\u3000-\u9FFF㉾]+$/.test(lastSymbol) && lastSymbol.length <= 10) {
                                console.log(`✅ Symbol decoded (last part): ${lastSymbol}`);
                                return lastSymbol;
                            }
                        } catch (e) {
                            console.log('❌ Last part decoding failed:', e.message);
                        }
                        
                        // Approach 4: Try the entire hex as a single string
                        try {
                            console.log(`🧪 Trying full hex as string...`);
                            const fullSymbol = hexToString(hex).trim();
                            console.log(`✨ Full decoded: "${fullSymbol}"`);
                            if (fullSymbol && /^[\w\u3000-\u9FFF㉾]+$/.test(fullSymbol) && fullSymbol.length <= 20) {
                                console.log(`✅ Symbol decoded (full): ${fullSymbol}`);
                                return fullSymbol;
                            }
                        } catch (e) {
                            console.log('❌ Full hex decoding failed:', e.message);
                        }
                    } else {
                        console.log(`⚠️ Hex too short: ${hex.length} characters`);
                    }
                } else {
                    console.log(`⚠️ Empty or null symbol result`);
                }
                
                console.log(`⚠️ Contract symbol lookup failed, trying Gecko Terminal...`);
                
            } catch (error) {
                console.log(`💥 Contract symbol lookup failed for ${address}: ${error.message}`);
            }
            
            // Fallback to Gecko Terminal API
            try {
                const geckoSymbol = await getTokenNameFromGecko(address);
                if (geckoSymbol) {
                    return geckoSymbol;
                }
            } catch (geckoError) {
                console.log(`💥 Gecko lookup also failed: ${geckoError.message}`);
            }
            
            // Final fallback to address-based name
            console.log(`❌ All symbol lookups failed for ${address}, using fallback`);
            return `Token_${address.slice(-4)}`;
        }

        // Get token name/symbol from Gecko Terminal API
        async function getTokenNameFromGecko(address) {
            try {
                const pulseChainId = 'pulsechain';
                const url = `https://api.geckoterminal.com/api/v2/networks/${pulseChainId}/tokens/${address.toLowerCase()}`;
                
                console.log(`🦎 Fetching token info from Gecko for ${address}...`);
                
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Gecko API: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.data && data.data.attributes) {
                    const attrs = data.data.attributes;
                    const symbol = attrs.symbol || attrs.name;
                    if (symbol) {
                        console.log(`✅ Got symbol from Gecko: ${symbol}`);
                        return symbol;
                    }
                }
                
                throw new Error('No symbol/name in Gecko response');
                
            } catch (error) {
                console.log(`❌ Gecko lookup failed for ${address}: ${error.message}`);
                return null;
            }
        }

        // Get multiplier using the exact ABI function Multiplier(uint256) with 0 parameter
        async function getMultiplier(address) {
            try {
                console.log(`🔢 Getting multiplier for ${address} using Multiplier(uint256) with 0 amount...`);
                
                const result = await makeRPCCall('eth_call', [
                    {
                        to: address,
                        data: '0x5677abcc' + '0000000000000000000000000000000000000000000000000000000000000000'
                    },
                    'latest'
                ]);
                
                console.log(`📥 Multiplier(0) result: ${result}`);
                
                if (result && result !== '0x') {
                    const multiplier = parseInt(result, 16);
                    console.log(`✅ Multiplier from Multiplier(0): ${multiplier}`);
                    
                    // Store for multi-hop integration
                    tokenMultipliers.set(address.toLowerCase(), multiplier);
                    
                    return multiplier;
                }
                
                console.log(`⚠️ No valid multiplier result for ${address}`);
                return 2.0; // Default to 2
                
            } catch (error) {
                console.log(`❌ Failed to get multiplier for ${address}: ${error.message}`);
                return 2.0; // Default to 2
            }
        }

        // Get parent token address
        async function getParentToken(address) {
            try {
                console.log(`Calling Parent() on ${address} with correct selector...`);
                
                const result = await makeRPCCall('eth_call', [
                    {
                        to: address,
                        data: '0xd3c8dd69'  // Correct Parent() function selector
                    },
                    'latest'
                ]);
                
                console.log(`Parent() result: ${result}`);
                
                if (result && result !== '0x' && result !== '0x0000000000000000000000000000000000000000000000000000000000000000') {
                    const parentAddress = '0x' + result.slice(-40);
                    const normalizedParent = parentAddress.toLowerCase();
                    
                    if (normalizedParent !== '0x0000000000000000000000000000000000000000') {
                        console.log(`✅ Found parent: ${parentAddress}`);
                        return parentAddress;
                    }
                }
                
                console.log(`❌ No valid parent found for ${address}`);
                return null;
                
            } catch (error) {
                console.log(`Parent lookup failed for ${address}: ${error.message}`);
                return null;
            }
        }

        // Store discovered token data for multi-hop integration
        function storeTokenDataForMultiHop() {
            try {
                if (discoveredTokens.length > 0) {
                    console.log('✅ Stored token data for multi-hop integration');
                }
                
                if (tokenMultipliers.size > 0) {
                    const multiplierObj = Object.fromEntries(tokenMultipliers);
                    console.log('✅ Stored multiplier data for multi-hop integration');
                }
            } catch (error) {
                console.error('❌ Failed to store token data:', error);
            }
        }

        // Toggle discovery log visibility
        function toggleDiscoveryLog() {
            const log = document.getElementById('discoveryLog');
            const btn = document.getElementById('logToggleBtn');
            
            if (log.style.display === 'none') {
                log.style.display = 'block';
                btn.textContent = '📄 Hide Log';
                btn.title = 'Hide discovery log';
            } else {
                log.style.display = 'none';
                btn.textContent = '📄 Show Log';
                btn.title = 'Show discovery log';
            }
        }

        // Test connection
        async function testConnection() {
            const testBtn = document.getElementById('testBtn');
            testBtn.disabled = true;
            testBtn.textContent = '🔄 Testing...';
            
            try {
                setStatus('Testing PulseChain connection...', 'loading');
                logDiscovery('Testing RPC connection...');
                
                const chainId = await makeRPCCall('eth_chainId');
                const blockNumber = await makeRPCCall('eth_blockNumber');
                
                const chainIdDecimal = parseInt(chainId, 16);
                const blockNumberDecimal = parseInt(blockNumber, 16);
                
                setStatus(`✅ Connected! Chain ID: ${chainIdDecimal}, Block: ${blockNumberDecimal}`, 'connected');
                logDiscovery(`✅ Connected to PulseChain! Block: ${blockNumberDecimal}`);
                testBtn.className = 'btn success';
                testBtn.textContent = '✅ Connected';
                
                setTimeout(() => {
                    testBtn.className = 'btn';
                    testBtn.textContent = '🔗 Test Connection';
                }, 3000);
                
            } catch (error) {
                console.error('Connection test failed:', error);
                setStatus(`❌ Connection failed: ${error.message}`, 'error');
                logDiscovery(`❌ Connection failed: ${error.message}`);
                testBtn.textContent = '❌ Failed';
                
                setTimeout(() => {
                    testBtn.textContent = '🔗 Test Connection';
                }, 3000);
            } finally {
                testBtn.disabled = false;
            }
        }

        // Discover the entire token spine
        async function discoverSpine() {
            const discoverBtn = document.getElementById('discoverBtn');
            const startingAddress = document.getElementById('startingToken').value.trim();
            
            if (!startingAddress || !startingAddress.startsWith('0x')) {
                alert('Please enter a valid token address starting with 0x');
                return;
            }
            
            discoverBtn.disabled = true;
            discoverBtn.textContent = '🧬 Discovering...';
            
            try {
                setStatus('Discovering token spine...', 'loading');
                
                // Clear previous results
                discoveredTokens = [];
                tokenMultipliers.clear();
                document.getElementById('discoveryLog').textContent = 'Starting spine discovery...';
                
                // Hide total multiplier section
                document.getElementById('totalMultiplierSection').style.display = 'none';
                
                logDiscovery(`Starting discovery from: ${startingAddress}`);
                
                // Test connection first
                await makeRPCCall('eth_chainId');
                
                let currentAddress = startingAddress.toLowerCase();
                let depth = 0;
                const maxDepth = 40;
                
                // Walk up the spine
                while (currentAddress && depth < maxDepth) {
                    logDiscovery(`Analyzing token ${depth + 1}: ${currentAddress}`);
                    
                    // Get token symbol
                    let tokenSymbol;
                    try {
                        console.log(`🚀 About to call getTokenSymbol for ${currentAddress}`);
                        tokenSymbol = await getTokenSymbol(currentAddress);
                        console.log(`🎯 getTokenSymbol returned: ${tokenSymbol}`);
                    } catch (symbolError) {
                        console.error(`💥 getTokenSymbol threw error:`, symbolError);
                        tokenSymbol = `Token_${currentAddress.slice(-4)}`;
                    }
                    
                    logDiscovery(`  → Symbol: ${tokenSymbol}`);
                    
                    // Get parent address
                    const parentAddress = await getParentToken(currentAddress);
                    
                    if (parentAddress) {
                        logDiscovery(`  → Parent found: ${parentAddress}`);
                        discoveredTokens.unshift({
                            name: tokenSymbol,
                            address: currentAddress,
                            type: 'child'
                        });
                        currentAddress = parentAddress.toLowerCase();
                    } else {
                        logDiscovery(`  → No parent found - this is the root token`);
                        discoveredTokens.unshift({
                            name: tokenSymbol,
                            address: currentAddress,
                            type: 'parent'
                        });
                        break;
                    }
                    
                    depth++;
                    
                    // Small delay to avoid overwhelming the RPC
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                if (depth >= maxDepth) {
                    logDiscovery(`⚠️ Reached maximum depth of ${maxDepth} tokens`);
                }
                
                logDiscovery(`\n✅ Discovery complete! Found ${discoveredTokens.length} tokens in spine:`);
                discoveredTokens.forEach((token, i) => {
                    logDiscovery(`  ${i + 1}. ${token.name} (${token.type})`);
                });
                
                // Build the table
                buildTokenTable();
                
                // Enable refresh button
                document.getElementById('refreshBtn').disabled = false;
                
                setStatus(`✅ Discovered ${discoveredTokens.length} tokens in spine!`, 'connected');
                
            } catch (error) {
                console.error('Discovery failed:', error);
                setStatus(`❌ Discovery failed: ${error.message}`, 'error');
                logDiscovery(`❌ Discovery failed: ${error.message}`);
            } finally {
                discoverBtn.disabled = false;
                discoverBtn.textContent = '🧬 Discover V4 Spine';
            }
        }

        // Build token table from discovered tokens
        function buildTokenTable() {
            const tableBody = document.getElementById('tokenTable');
            tableBody.innerHTML = '';
            
            discoveredTokens.forEach((token, index) => {
                const row = document.createElement('tr');
                row.className = token.type === 'parent' ? 'parent-row' : 'child-row';
                row.id = `token-row-${index}`;
                
                row.innerHTML = `
                    <td>${token.type === 'parent' ? '🏛️ Parent' : `👶 Child ${index}`}</td>
                    <td class="token-name">${token.name}</td>
                    <td class="address" onclick="copyAddress('${token.address}')" title="Click to copy">${token.address.substring(0, 6)}...${token.address.substring(token.address.length - 4)}</td>
                    <td class="loading-cell">Loading...</td>
                    <td class="loading-cell">${token.type === 'parent' ? 'N/A' : 'Reading...'}</td>
                    <td class="loading-cell">Loading...</td>
                    <td class="loading-cell">${token.type === 'parent' ? 'N/A' : 'Calculating...'}</td>
                    <td>${token.type === 'child' ? `<button class="mint-btn" onclick="openMintModal(${index})">Mint</button>` : 'N/A'}</td>
                `;
                
                tableBody.appendChild(row);
            });
        }

        function copyAddress(address) {
            navigator.clipboard.writeText(address);
        }

        // Calculate and update total multiplier
        function updateTotalMultiplier(tokenData) {
            let totalMultiplier = 1;
            let parentPrice = 0;
            
            // Calculate total multiplier and get parent price
            for (let i = 0; i < tokenData.length; i++) {
                const data = tokenData[i];
                if (!data) continue;
                
                if (data.token.type === 'parent') {
                    parentPrice = data.priceData.price;
                } else if (data.token.type === 'child' && data.multiplier) {
                    totalMultiplier *= data.multiplier;
                }
            }
            
            // Show the section if we have child tokens
            const hasChildTokens = tokenData.some(data => data && data.token.type === 'child');
            const section = document.getElementById('totalMultiplierSection');
            
            if (hasChildTokens && parentPrice > 0) {
                section.style.display = 'block';
                
                const impliedPrice = parentPrice * totalMultiplier;
                
                document.getElementById('totalMultiplierValue').textContent = `${totalMultiplier.toLocaleString()}x`;
                document.getElementById('impliedPriceValue').textContent = `${formatPrice(impliedPrice)}`;
                
                console.log(`📊 Total Multiplier: ${totalMultiplier}x, Parent Price: ${parentPrice.toFixed(6)}, Implied Price: ${impliedPrice.toFixed(6)}`);
            } else {
                section.style.display = 'none';
            }
        }

        // Utility functions
        function formatNumber(num) {
            if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
            if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
            if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';
            return num.toFixed(2);
        }

        // Refresh data for discovered tokens
        async function refreshData() {
            if (discoveredTokens.length === 0) {
                alert('No tokens discovered yet. Click "Discover V4 Spine" first.');
                return;
            }
            
            const refreshBtn = document.getElementById('refreshBtn');
            refreshBtn.disabled = true;
            refreshBtn.textContent = '🔄 Loading...';
            
            try {
                setStatus('Loading token data with corrected multipliers and parity calculations...', 'loading');
                
                // Store token data for parity calculations
                const tokenData = [];
                
                // First pass: collect all data
                for (let i = 0; i < discoveredTokens.length; i++) {
                    const token = discoveredTokens[i];
                    const row = document.getElementById(`token-row-${i}`);
                    
                    if (!row) continue;
                    
                    try {
                        // Get token symbol for better naming
                        let tokenSymbol;
                        try {
                            tokenSymbol = await getTokenSymbol(token.address);
                            token.name = tokenSymbol;
                        } catch (symbolError) {
                            console.log(`⚠️ Symbol lookup failed for ${token.name}: ${symbolError.message}`);
                        }
                        
                        // Get total supply
                        const totalSupplyResult = await makeRPCCall('eth_call', [
                            {
                                to: token.address,
                                data: '0x18160ddd' + '0'.repeat(56)
                            },
                            'latest'
                        ]);
                        
                        const totalSupply = parseInt(totalSupplyResult, 16) / Math.pow(10, 18);
                        
                        // Get multiplier for child tokens
                        let multiplier = null;
                        if (token.type === 'child') {
                            try {
                                multiplier = await getMultiplier(token.address);
                                console.log(`✅ Got correct multiplier for ${token.name}: ${multiplier}`);
                            } catch (e) {
                                console.log(`❌ Multiplier lookup failed for ${token.name}: ${e.message}`);
                                multiplier = 2.0; // Default fallback
                            }
                        }
                        
                        // Get REAL price data
                        const priceData = await getPulseXPriceWithHierarchy(token.address);
                        
                        // Store data for parity calculations
                        tokenData[i] = {
                            index: i,
                            token: token,
                            totalSupply: totalSupply,
                            multiplier: multiplier,
                            priceData: priceData,
                            symbol: tokenSymbol
                        };
                        
                    } catch (error) {
                        console.error(`Error loading data for ${token.name}:`, error);
                        
                        // Fallback data
                        const addressNum = parseInt(token.address.slice(-4), 16);
                        const mockTotalSupply = (addressNum % 100000) * 10000;
                        const mockPrice = (addressNum % 1000) / 1000000 + Math.random() * 0.0001;
                        
                        tokenData[i] = {
                            index: i,
                            token: token,
                            totalSupply: mockTotalSupply,
                            multiplier: token.type === 'child' ? 2.0 : null,
                            priceData: { price: mockPrice, priceChange24h: 0, pairInfo: 'Mock data' },
                            symbol: token.name
                        };
                    }
                    
                    // Small delay to avoid rate limiting
                    if (i < discoveredTokens.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                
                // Second pass: update UI with parity calculations
                for (let i = 0; i < tokenData.length; i++) {
                    const data = tokenData[i];
                    if (!data) continue;
                    
                    const row = document.getElementById(`token-row-${i}`);
                    if (!row) continue;
                    
                    const cells = row.children;
                    
                    // Update token name
                    cells[1].textContent = data.symbol;
                    
                    // Update total supply
                    cells[3].textContent = formatNumber(data.totalSupply);
                    cells[3].className = '';
                    
                    // Update multiplier
                    if (data.token.type === 'child') {
                        cells[4].innerHTML = `<span class="multiplier">${Math.round(data.multiplier)}x</span>`;
                        cells[4].className = '';
                    }
                    
                    // Update price
                    const formattedPrice = formatPrice(data.priceData.price);
                    cells[5].innerHTML = `${formattedPrice}<br><span class="price-source">${data.priceData.pairInfo || data.priceData.source}</span>`;
                    cells[5].className = data.priceData.priceChange24h >= 0 ? 'price' : 'price negative';
                    
                    // Calculate and update parity percentage
                    if (data.token.type === 'child' && i > 0) {
                        const parentData = tokenData[i - 1]; // Parent is the previous token
                        if (parentData && parentData.priceData.price > 0 && data.priceData.price > 0) {
                            // Calculate: (Child Price / (Parent Price × Multiplier)) × 100
                            const expectedChildPrice = parentData.priceData.price * data.multiplier;
                            const parityPercentage = (data.priceData.price / expectedChildPrice) * 100;
                            
                            const parityClass = parityPercentage >= 100 ? 'profitable' : 'unprofitable';
                            cells[6].innerHTML = `<span class="parity ${parityClass}">${parityPercentage.toFixed(1)}%</span>`;
                            cells[6].className = '';
                            
                            console.log(`💰 Parity for ${data.symbol}: ${parityPercentage.toFixed(1)}% (Parent: ${parentData.priceData.price.toFixed(6)}, Multiplier: ${data.multiplier}x, Child: ${data.priceData.price.toFixed(6)})`);
                        } else {
                            cells[6].textContent = 'N/A';
                            cells[6].className = '';
                        }
                    } else {
                        // Parent token doesn't have parity
                        cells[6].textContent = 'N/A';
                        cells[6].className = '';
                    }
                }
                
                // Update total multiplier section
                updateTotalMultiplier(tokenData);
                
                setStatus('Data loaded successfully with parity calculations!', 'connected');
                document.getElementById('lastUpdate').textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
                
            } catch (error) {
                console.error('Refresh failed:', error);
                setStatus(`❌ Refresh failed: ${error.message}`, 'error');
            } finally {
                refreshBtn.disabled = false;
                refreshBtn.textContent = '🔄 Refresh Data';
            }
        }

        // Auto-refresh toggle
        function toggleAutoRefresh() {
            const btn = document.getElementById('autoRefreshBtn');
            const interval = parseInt(document.getElementById('refreshInterval').value) * 1000;
            
            if (isAutoRefreshing) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                isAutoRefreshing = false;
                btn.textContent = '⏰ Auto-Refresh: OFF';
                btn.style.background = 'linear-gradient(45deg, #6a4c93, #9d4edd)';
            } else {
                if (discoveredTokens.length === 0) {
                    alert('Please discover a token spine first before enabling auto-refresh.');
                    return;
                }
                autoRefreshInterval = setInterval(refreshData, interval);
                isAutoRefreshing = true;
                btn.textContent = `⏰ Auto-Refresh: ON (${interval/1000}s)`;
                btn.style.background = 'linear-gradient(45deg, #27ae60, #2ecc71)';
            }
        }

        // ENHANCED MINT FUNCTION WITH MULTI-HOP SUPPORT
        function openMintModal(tokenIndex) {
            const token = discoveredTokens[tokenIndex];
            if (!token) return;
            
            const parentToken = getParentTokenForMint(tokenIndex);
            const multiplier = getMultiplierForToken(tokenIndex);
            
            // Create URL parameters for the mint page with multi-hop data
            const params = new URLSearchParams({
                childToken: token.address,
                childName: token.name,
                parentToken: parentToken.address,
                parentName: parentToken.name,
                multiplier: multiplier,
                tokenIndex: tokenIndex,
                // NEW: Pass discovered tokens for multi-hop integration
                tokenChain: encodeURIComponent(JSON.stringify(discoveredTokens))
            });
            
            // NEW: Store data for multi-hop integration
            storeTokenDataForMultiHop();
            
            // Open mint page in new tab
            window.open(`mint.html?${params.toString()}`, '_blank');
            
            console.log('🚀 Opening mint page with enhanced data:', {
                token: token,
                parentToken: parentToken,
                discoveredTokensCount: discoveredTokens.length,
                tokenMultipliersCount: tokenMultipliers.size
            });
        }
        
        function getParentTokenForMint(tokenIndex) {
            if (tokenIndex === 0) {
                return {
                    address: "0x0000000000000000000000000000000000000000",
                    name: "Root Token"
                };
            }
            const parentToken = discoveredTokens[tokenIndex - 1];
            return {
                address: parentToken?.address || "0x0000000000000000000000000000000000000000",
                name: parentToken?.name || "Unknown Parent"
            };
        }
        
        function getMultiplierForToken(tokenIndex) {
            // Try to get multiplier from the table cell
            const row = document.getElementById(`token-row-${tokenIndex}`);
            if (row) {
                const multiplierCell = row.children[4]; // Multiplier is 5th column (index 4)
                const multiplierSpan = multiplierCell.querySelector('.multiplier');
                if (multiplierSpan) {
                    return multiplierSpan.textContent.replace('x', '');
                }
            }
            return '1.0'; // Default multiplier
        }

        // Initialize on load
        window.onload = function() {
            console.log('🧬 Enhanced Dynamic Spine Token Tracker Loading...');
            
            // Auto-test connection after a short delay
            setTimeout(testConnection, 1000);
        };

        // Cleanup and store data on page unload
        window.addEventListener('beforeunload', function() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }
            storeTokenDataForMultiHop();
        });

        // Global functions for console debugging
        window.DynamicTracker = {
            discoverSpine,
            refreshData,
            testConnection,
            makeRPCCall,
            getParentToken,
            getTokenSymbol,
            getMultiplier,
            discoveredTokens: () => discoveredTokens,
            tokenMultipliers: () => tokenMultipliers,
            priceCache: () => priceCache,
            debugDiscovery: async function(address) {
                console.log('=== DEBUGGING TOKEN DISCOVERY ===');
                console.log(`Starting from: ${address}`);
                
                try {
                    const symbol = await getTokenSymbol(address);
                    console.log(`Token symbol: ${symbol}`);
                    
                    const parent = await getParentToken(address);
                    console.log(`Parent token: ${parent || 'None (this is root)'}`);
                    
                    if (parent) {
                        const parentSymbol = await getTokenSymbol(parent);
                        console.log(`Parent symbol: ${parentSymbol}`);
                    }
                    
                    const multiplier = await getMultiplier(address);
                    console.log(`Multiplier: ${multiplier}`);
                    
                } catch (error) {
                    console.error('Debug failed:', error);
                }
            }
        };

        console.log('🚀 Enhanced Dynamic Spine Token Tracker loaded!');
        console.log('🔢 Added Total Multiplier and Implied Price calculations!');
        console.log('📊 Total Multiplier = Product of all child multipliers');
        console.log('💰 Implied Price = Parent Price × Total Multiplier');
        console.log('🎯 Multi-hop data passing enabled!');
        console.log('Try DynamicTracker.debugDiscovery("0x...") to test discovery on any token');
        console.log('Example: DynamicTracker.debugDiscovery("0x7e264cd4fa2354078f527f6a72afbadc0ba89d26")');
    </script>
</body>
</html>
                
