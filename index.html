<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Spine Token Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            padding: 20px;
            color: #e0e0e0;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(20, 20, 40, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(157, 78, 221, 0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #ffffff;
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #9d4edd, #6a4c93, #3a86ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(157, 78, 221, 0.3);
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .btn {
            background: linear-gradient(45deg, #6a4c93, #9d4edd);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(157, 78, 221, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(157, 78, 221, 0.4);
            background: linear-gradient(45deg, #9d4edd, #3a86ff);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn.success {
            background: linear-gradient(45deg, #06ffa5, #00cc88);
            box-shadow: 0 4px 15px rgba(6, 255, 165, 0.3);
        }
        
        .btn.discover {
            background: linear-gradient(45deg, #3a86ff, #06ffa5);
            box-shadow: 0 4px 15px rgba(58, 134, 255, 0.3);
        }
        
        .status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .status.connected {
            background: rgba(6, 255, 165, 0.2);
            color: #06ffa5;
            border: 1px solid rgba(6, 255, 165, 0.3);
        }
        
        .status.error {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }
        
        .status.loading {
            background: rgba(157, 78, 221, 0.2);
            color: #9d4edd;
            border: 1px solid rgba(157, 78, 221, 0.3);
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .config-section {
            background: rgba(102, 126, 234, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 25px;
            border: 2px solid rgba(102, 126, 234, 0.2);
        }
        
        .config-title {
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }
        
        .config-item {
            display: inline-block;
            margin-right: 20px;
            margin-bottom: 10px;
        }
        
        .config-item label {
            font-size: 0.9rem;
            color: #c0c0c0;
            font-weight: 500;
            margin-right: 10px;
        }
        
        .config-item input {
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            font-size: 0.9rem;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            width: 400px;
        }
        
        .config-item input::placeholder {
            color: #888;
        }
        
        .discovery-log {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #c0c0c0;
        }
        
        .table-container {
            overflow-x: auto;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(30, 30, 60, 0.8);
            font-size: 0.85rem;
            border-radius: 15px;
            overflow: hidden;
        }
        
        th {
            background: linear-gradient(45deg, #6a4c93, #9d4edd);
            color: white;
            padding: 12px 8px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            font-size: 0.8rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        td {
            padding: 10px 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background-color 0.3s ease;
            color: #e0e0e0;
        }
        
        tr:hover {
            background-color: rgba(157, 78, 221, 0.1);
        }
        
        .parent-row {
            background: rgba(6, 255, 165, 0.2);
            border-left: 4px solid #06ffa5;
            font-weight: 600;
        }
        
        .child-row {
            background: rgba(157, 78, 221, 0.1);
            border-left: 4px solid #9d4edd;
        }
        
        .token-name {
            font-weight: 600;
            color: #ffffff;
        }
        
        .address {
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            color: #90a4ae;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        
        .address:hover {
            color: #9d4edd;
        }
        
        .price {
            font-weight: 600;
            color: #06ffa5;
            font-family: 'Courier New', monospace;
            text-align: right;
        }
        
        .price.negative {
            color: #f44336;
        }
        
        .multiplier {
            background: linear-gradient(45deg, #3a86ff, #6a4c93);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: 600;
            text-align: right;
            min-width: 60px;
            font-size: 0.8rem;
            font-family: 'Courier New', monospace;
            box-shadow: 0 2px 8px rgba(58, 134, 255, 0.3);
            display: inline-block;
        }
        
        .loading-cell {
            text-align: center;
            color: #90a4ae;
            font-style: italic;
        }
        
        .price-source {
            font-size: 0.7rem;
            color: #888;
            font-style: italic;
        }
        
        .mint-btn {
            background: linear-gradient(45deg, #3a86ff, #06ffa5);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(58, 134, 255, 0.3);
        }
        
        .mint-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(58, 134, 255, 0.4);
        }
        
        .footer {
            text-align: center;
            margin-top: 30px;
            color: #90a4ae;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            table {
                font-size: 0.75rem;
            }
            
            th, td {
                padding: 6px 4px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Dynamic Spine Token Tracker</h1>
            <p>Automatically discover CC7 factory token spines by walking up from any child token</p>
            <div style="background: rgba(157, 78, 221, 0.1); padding: 15px; border-radius: 10px; margin-top: 15px; border: 2px solid rgba(157, 78, 221, 0.2);">
                <strong>‚ö†Ô∏è Entertainment Purposes Only:</strong> This tool is for entertainment purposes. All data should be independently verified before making any financial decisions. Always DYOR (Do Your Own Research).
            </div>
        </div>
        
        <div class="config-section">
            <div class="config-title">
                üîß Configuration
                <button onclick="toggleDiscoveryLog()" id="logToggleBtn" style="float: right; background: rgba(157, 78, 221, 0.3); border: 1px solid rgba(157, 78, 221, 0.5); color: #9d4edd; padding: 4px 8px; border-radius: 6px; font-size: 0.8rem; cursor: pointer;">
                    üìÑ Hide Log
                </button>
            </div>
            <div class="config-item">
                <label>RPC URL:</label>
                <input type="text" id="rpcUrl" value="https://rpc-pulsechain.g4mm4.io">
            </div>
            <div class="config-item">
                <label>Starting CC7 Token Address (lowest child):</label>
                <input type="text" id="startingToken" value="0xea4ff5498882b63b1c4a6c9f6f43c219beaf9628" placeholder="0x...">
            </div>
            <div class="config-item">
                <label>Auto-refresh interval (seconds):</label>
                <input type="number" id="refreshInterval" value="300" min="10" max="600" style="width: 100px;">
            </div>
            
            <div class="discovery-log" id="discoveryLog" style="max-height: 100px;">
                Ready to discover CC7 token spine... Enter a CC7 child token address and click "Discover CC7 Spine"
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <button class="btn" onclick="testConnection()" id="testBtn">
                    üîó Test Connection
                </button>
                <button class="btn discover" onclick="discoverSpine()" id="discoverBtn">
                    üß¨ Discover CC7 Spine
                </button>
                <button class="btn" onclick="refreshData()" id="refreshBtn" disabled>
                    üîÑ Refresh Data
                </button>
                <button class="btn" onclick="toggleAutoRefresh()" id="autoRefreshBtn">
                    ‚è∞ Auto-Refresh: OFF
                </button>
            </div>
            
            <div class="control-group">
                <div class="status" id="status">
                    <div class="status-dot"></div>
                    <span>Ready to connect</span>
                </div>
                <div style="font-size: 0.8rem; color: #90a4ae;" id="lastUpdate">
                    Last updated: Never
                </div>
            </div>
        </div>
        
        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Position</th>
                        <th>Token Name</th>
                        <th>Contract Address</th>
                        <th>Total Supply</th>
                        <th>Multiplier</th>
                        <th>Price (USD)</th>
                        <th>Market Cap</th>
                        <th style="width: 60px;">Mint</th>
                    </tr>
                </thead>
                <tbody id="tokenTable">
                    <tr>
                        <td colspan="8" style="text-align: center; padding: 40px; color: #90a4ae;">
                            No CC7 tokens discovered yet. Click "Discover CC7 Spine" to start building the spine from a CC7 child token.
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="footer">
            <p><strong>Instructions:</strong> 1) Enter any CC7 child token address ‚Üí 2) Click "Discover CC7 Spine" ‚Üí 3) Click "Refresh Data" to load prices/multipliers</p>
            <p><strong>Price Colors:</strong> Green = 24h price increase, Red = 24h price decrease</p>
            <p><strong>Enhanced Pricing:</strong> Prioritizes PLS pairs ‚Üí USDC/USDT ‚Üí ETH pairs for maximum accuracy</p>
            <p><strong>Note:</strong> This tool only works with tokens created from the CC7 factory. Please avoid using auto-refresh to limit RPC calls and be respectful of the infrastructure</p>
            <p><strong>Chain:</strong> PulseChain (Chain ID: 369) | <strong>RPC:</strong> G4mm4.io</p>
            
            <div style="margin-top: 30px; padding: 20px; background: rgba(157, 78, 221, 0.1); border-radius: 15px; border: 2px solid rgba(157, 78, 221, 0.2); text-align: left;">
                <p style="margin-bottom: 15px;">The provided information may not be 100% accurate and still needs some testing.</p>
                <p style="margin-bottom: 10px;"><strong>Your support is greatly appreciated and helps me continue improving the website.</strong></p>
                <p style="font-family: 'Courier New', monospace; background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 8px; margin: 10px 0; word-break: break-all; font-size: 0.85rem;">0x809b15CCdC92882035C274738318296525b98aD8</p>
                
                <p style="margin-top: 20px; margin-bottom: 10px;"><strong>Disclaimer:</strong></p>
                <p style="margin-bottom: 10px; font-size: 0.9rem; line-height: 1.4;">All content provided on this site is for informational purposes only and does not constitute financial advice. None of the information presented here should be considered as investment advice or a recommendation to buy, sell, or hold any financial product or instrument.</p>
                
                <p style="margin-bottom: 10px; font-size: 0.9rem; line-height: 1.4;">Please perform your own research and consult with a qualified financial advisor before making any investment decisions. We do not take responsibility for any financial losses you may incur as a result of using the information provided on this site.</p>
                
                <p style="margin-bottom: 0; font-size: 0.9rem; line-height: 1.4;">Remember, all investments carry risk, and past performance is not indicative of future results.</p>
            </div>
        </div>
    </div>

    <script>
        // Discovered tokens will be stored here
        let discoveredTokens = [];
        let autoRefreshInterval = null;
        let isAutoRefreshing = false;
        
        // Price cache to avoid hammering APIs
        const priceCache = new Map();
        const CACHE_DURATION = 60000; // 1 minute

        // RPC call function
        async function makeRPCCall(method, params = []) {
            const rpcUrl = document.getElementById('rpcUrl').value;
            
            const response = await fetch(rpcUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    method: method,
                    params: params,
                    id: Date.now()
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            if (data.error) {
                throw new Error(`RPC Error: ${data.error.message}`);
            }
            
            return data.result;
        }

        // Status and logging functions
        function setStatus(message, type = 'loading') {
            const status = document.getElementById('status');
            status.className = `status ${type}`;
            status.querySelector('span').textContent = message;
        }

        function logDiscovery(message) {
            const log = document.getElementById('discoveryLog');
            const timestamp = new Date().toLocaleTimeString();
            log.textContent += `\n[${timestamp}] ${message}`;
            log.scrollTop = log.scrollHeight;
        }

        // Format price with commas for readability
        function formatPrice(price) {
            if (price < 1) {
                return price.toFixed(5);
            } else {
                return price.toLocaleString('en-US', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            }
        }

        // Browser-compatible hex to string conversion
        function hexToString(hex) {
            let result = '';
            for (let i = 0; i < hex.length; i += 2) {
                const byte = parseInt(hex.substr(i, 2), 16);
                if (byte !== 0) { // Skip null bytes
                    result += String.fromCharCode(byte);
                }
            }
            return result.replace(/[^\x20-\x7E]/g, ''); // Remove non-printable characters
        }

        // Enhanced pricing function with hierarchy
        async function getPulseXPriceWithHierarchy(tokenAddress) {
            console.log(`üîç Getting price for ${tokenAddress} with proper hierarchy...`);
            
            // Check cache first
            const cacheKey = `price_${tokenAddress.toLowerCase()}`;
            const cached = priceCache.get(cacheKey);
            if (cached && (Date.now() - cached.timestamp) < CACHE_DURATION) {
                console.log(`üìã Using cached price for ${tokenAddress}`);
                return cached.data;
            }
            
            // Define pricing source hierarchy for PulseChain
            const pricingSources = [
                {
                    name: 'GeckoTerminal_PLS',
                    priority: 1,
                    description: 'PLS pairs via GeckoTerminal'
                },
                {
                    name: 'GeckoTerminal_USD',
                    priority: 2,
                    description: 'USD price via GeckoTerminal'
                },
                {
                    name: 'DexScreener_PulseChain',
                    priority: 3,
                    description: 'PulseChain pairs via DexScreener'
                }
            ];

            // Try each pricing source in order of priority
            for (const source of pricingSources) {
                try {
                    console.log(`üí∞ Trying ${source.name}: ${source.description}`);
                    
                    let priceData = null;
                    
                    if (source.name.startsWith('GeckoTerminal')) {
                        priceData = await getGeckoTerminalPrice(tokenAddress, source.name === 'GeckoTerminal_PLS');
                    } else if (source.name.startsWith('DexScreener')) {
                        priceData = await getDexScreenerPrice(tokenAddress, true);
                    }
                    
                    if (priceData && priceData.price > 0) {
                        console.log(`‚úÖ Got price from ${source.name}: ${priceData.price}`);
                        priceData.source = source.description;
                        priceData.priority = source.priority;
                        
                        // Cache the result
                        priceCache.set(cacheKey, {
                            data: priceData,
                            timestamp: Date.now()
                        });
                        
                        return priceData;
                    }
                    
                } catch (error) {
                    console.log(`‚ùå ${source.name} failed: ${error.message}`);
                    continue;
                }
            }
            
            // Fallback to address-based mock data
            console.log(`‚ö†Ô∏è All pricing sources failed, using fallback data`);
            return getFallbackPriceData(tokenAddress);
        }

        // Enhanced GeckoTerminal function with PLS pair preference
        async function getGeckoTerminalPrice(tokenAddress, preferPLSPairs = false) {
            const pulseChainId = 'pulsechain';
            const url = `https://api.geckoterminal.com/api/v2/networks/${pulseChainId}/tokens/${tokenAddress.toLowerCase()}`;
            
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`GeckoTerminal API: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.data && data.data.attributes) {
                const attrs = data.data.attributes;
                let pairInfo = 'USD price';
                
                // If we prefer PLS pairs, try to get PLS-denominated price first
                if (preferPLSPairs && data.included) {
                    const plsPairs = data.included.filter(item => 
                        item.type === 'pool' && 
                        (item.attributes.base_token_name?.toLowerCase().includes('pls') ||
                         item.attributes.quote_token_name?.toLowerCase().includes('pls'))
                    );
                    
                    if (plsPairs.length > 0) {
                        console.log(`üéØ Found ${plsPairs.length} PLS pairs, using highest liquidity`);
                        const bestPLSPair = plsPairs.sort((a, b) => 
                            parseFloat(b.attributes.reserve_in_usd || '0') - parseFloat(a.attributes.reserve_in_usd || '0')
                        )[0];
                        
                        pairInfo = `${bestPLSPair.attributes.name} (PLS pair)`;
                    }
                }
                
                return {
                    price: parseFloat(attrs.price_usd || '0'),
                    volume24h: parseFloat(attrs.volume_usd?.h24 || '0'),
                    priceChange24h: parseFloat(attrs.price_change_percentage?.h24 || '0'),
                    pairInfo: pairInfo
                };
            }
            
            throw new Error('No price data in GeckoTerminal response');
        }

        // Enhanced DexScreener function with PulseChain preference
        async function getDexScreenerPrice(tokenAddress, preferPulseChain = true) {
            const url = `https://api.dexscreener.com/latest/dex/tokens/${tokenAddress}`;
            
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`DexScreener API: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.pairs && data.pairs.length > 0) {
                let selectedPair = null;
                
                if (preferPulseChain) {
                    // Priority 1: PLS pairs on PulseChain
                    const plsPairs = data.pairs.filter(pair => 
                        pair.chainId === 'pulsechain' && 
                        (pair.baseToken?.symbol?.toLowerCase() === 'pls' || 
                         pair.quoteToken?.symbol?.toLowerCase() === 'pls')
                    );
                    
                    if (plsPairs.length > 0) {
                        selectedPair = plsPairs.sort((a, b) => parseFloat(b.liquidity?.usd || '0') - parseFloat(a.liquidity?.usd || '0'))[0];
                        console.log(`üéØ Using PLS pair: ${selectedPair.pairAddress}`);
                    }
                    
                    // Priority 2: Stablecoin pairs on PulseChain
                    if (!selectedPair) {
                        const stablePairs = data.pairs.filter(pair => 
                            pair.chainId === 'pulsechain' && 
                            ['usdc', 'usdt', 'dai', 'busd'].includes(
                                pair.quoteToken?.symbol?.toLowerCase() || pair.baseToken?.symbol?.toLowerCase()
                            )
                        );
                        
                        if (stablePairs.length > 0) {
                            selectedPair = stablePairs.sort((a, b) => parseFloat(b.liquidity?.usd || '0') - parseFloat(a.liquidity?.usd || '0'))[0];
                            console.log(`üí∞ Using stablecoin pair: ${selectedPair.pairAddress}`);
                        }
                    }
                    
                    // Priority 3: Any PulseChain pair
                    if (!selectedPair) {
                        const pulsePairs = data.pairs.filter(pair => pair.chainId === 'pulsechain');
                        if (pulsePairs.length > 0) {
                            selectedPair = pulsePairs.sort((a, b) => parseFloat(b.liquidity?.usd || '0') - parseFloat(a.liquidity?.usd || '0'))[0];
                            console.log(`‚ö° Using PulseChain pair: ${selectedPair.pairAddress}`);
                        }
                    }
                }
                
                // Fallback to highest liquidity pair
                if (!selectedPair) {
                    selectedPair = data.pairs.sort((a, b) => parseFloat(b.liquidity?.usd || '0') - parseFloat(a.liquidity?.usd || '0'))[0];
                    console.log(`üìä Using highest liquidity pair: ${selectedPair.pairAddress}`);
                }
                
                if (selectedPair) {
                    return {
                        price: parseFloat(selectedPair.priceUsd || '0'),
                        volume24h: parseFloat(selectedPair.volume?.h24 || '0'),
                        priceChange24h: parseFloat(selectedPair.priceChange?.h24 || '0'),
                        pairInfo: `${selectedPair.baseToken?.symbol}/${selectedPair.quoteToken?.symbol} on ${selectedPair.dexId}`
                    };
                }
            }
            
            throw new Error('No suitable pairs found on DexScreener');
        }

        // Fallback price data generator
        function getFallbackPriceData(tokenAddress) {
            return {
                price: 0,
                volume24h: 0,
                priceChange24h: 0,
                source: 'No pricing data available',
                priority: 999,
                pairInfo: 'No pairs found'
            };
        }

        // Get token name/symbol from Gecko Terminal API
        async function getTokenNameFromGecko(address) {
            try {
                const pulseChainId = 'pulsechain';
                const url = `https://api.geckoterminal.com/api/v2/networks/${pulseChainId}/tokens/${address.toLowerCase()}`;
                
                console.log(`ü¶é Fetching token info from Gecko for ${address}...`);
                
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Gecko API: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.data && data.data.attributes) {
                    const attrs = data.data.attributes;
                    const symbol = attrs.symbol || attrs.name;
                    if (symbol) {
                        console.log(`‚úÖ Got symbol from Gecko: ${symbol}`);
                        return symbol;
                    }
                }
                
                throw new Error('No symbol/name in Gecko response');
                
            } catch (error) {
                console.log(`‚ùå Gecko lookup failed for ${address}: ${error.message}`);
                return null;
            }
        }

        // Get token symbol from contract (shorter identifier)
        async function getTokenSymbol(address) {
            console.log(`üîç getTokenSymbol called for ${address}`);
            
            try {
                console.log(`üîç Getting symbol from contract for ${address}...`);
                
                const symbolResult = await makeRPCCall('eth_call', [
                    {
                        to: address,
                        data: '0x95d89b41'
                    },
                    'latest'
                ]);
                
                console.log(`üì• Symbol result for ${address}: ${symbolResult}`);
                
                if (symbolResult && symbolResult !== '0x') {
                    const hex = symbolResult.slice(2);
                    console.log(`üî§ Processing hex: ${hex}`);
                    
                    if (hex.length >= 64) {
                        // Try different decoding approaches
                        
                        // Approach 1: Standard ABI encoding
                        if (hex.length >= 128) {
                            try {
                                console.log(`üß™ Trying standard ABI decoding...`);
                                const lengthHex = hex.substring(64, 128);
                                const length = parseInt(lengthHex, 16);
                                console.log(`üìê Decoded length: ${length}`);
                                if (length > 0 && length < 100) {
                                    const symbolHex = hex.substring(128, 128 + (length * 2));
                                    console.log(`üî§ Symbol hex: ${symbolHex}`);
                                    const symbol = hexToString(symbolHex);
                                    console.log(`‚ú® Decoded symbol: "${symbol}"`);
                                    if (symbol && symbol.length > 0 && /^[A-Za-z0-9]+$/.test(symbol)) {
                                        console.log(`‚úÖ Symbol decoded (standard): ${symbol}`);
                                        return symbol;
                                    }
                                }
                            } catch (e) {
                                console.log('‚ùå Standard ABI decoding failed:', e.message);
                            }
                        }
                        
                        // Approach 2: Direct hex to string
                        try {
                            console.log(`üß™ Trying direct hex decoding...`);
                            const cleanHex = hex.replace(/^0+/, '');
                            console.log(`üßπ Clean hex: ${cleanHex}`);
                            if (cleanHex.length > 0 && cleanHex.length <= 64) {
                                const directSymbol = hexToString(cleanHex);
                                console.log(`‚ú® Direct decoded: "${directSymbol}"`);
                                if (directSymbol && /^[A-Za-z0-9]+$/.test(directSymbol) && directSymbol.length <= 10) {
                                    console.log(`‚úÖ Symbol decoded (direct): ${directSymbol}`);
                                    return directSymbol;
                                }
                            }
                        } catch (e) {
                            console.log('‚ùå Direct hex decoding failed:', e.message);
                        }
                        
                        // Approach 3: Try last 32 bytes
                        try {
                            console.log(`üß™ Trying last part decoding...`);
                            const lastPart = hex.slice(-64);
                            console.log(`üîö Last part: ${lastPart}`);
                            const lastSymbol = hexToString(lastPart);
                            console.log(`‚ú® Last decoded: "${lastSymbol}"`);
                            if (lastSymbol && /^[A-Za-z0-9]+$/.test(lastSymbol) && lastSymbol.length <= 10) {
                                console.log(`‚úÖ Symbol decoded (last part): ${lastSymbol}`);
                                return lastSymbol;
                            }
                        } catch (e) {
                            console.log('‚ùå Last part decoding failed:', e.message);
                        }
                        
                        // Approach 4: Try the entire hex as a single string
                        try {
                            console.log(`üß™ Trying full hex as string...`);
                            const fullSymbol = hexToString(hex).trim();
                            console.log(`‚ú® Full decoded: "${fullSymbol}"`);
                            if (fullSymbol && /^[A-Za-z0-9]+$/.test(fullSymbol) && fullSymbol.length <= 20) {
                                console.log(`‚úÖ Symbol decoded (full): ${fullSymbol}`);
                                return fullSymbol;
                            }
                        } catch (e) {
                            console.log('‚ùå Full hex decoding failed:', e.message);
                        }
                    } else {
                        console.log(`‚ö†Ô∏è Hex too short: ${hex.length} characters`);
                    }
                } else {
                    console.log(`‚ö†Ô∏è Empty or null symbol result`);
                }
                
                console.log(`‚ö†Ô∏è Contract symbol lookup failed, trying Gecko Terminal...`);
                
            } catch (error) {
                console.log(`üí• Contract symbol lookup failed for ${address}: ${error.message}`);
            }
            
            // Fallback to Gecko Terminal API
            try {
                const geckoSymbol = await getTokenNameFromGecko(address);
                if (geckoSymbol) {
                    return geckoSymbol;
                }
            } catch (geckoError) {
                console.log(`üí• Gecko lookup also failed: ${geckoError.message}`);
            }
            
            // Final fallback to address-based name
            console.log(`‚ùå All symbol lookups failed for ${address}, using fallback`);
            return `Token_${address.slice(-4)}`;
        }

        // Get parent token address
        async function getParentToken(address) {
            try {
                console.log(`Calling Parent() on ${address} with correct selector...`);
                
                const result = await makeRPCCall('eth_call', [
                    {
                        to: address,
                        data: '0xd3c8dd69'  // Correct Parent() function selector
                    },
                    'latest'
                ]);
                
                console.log(`Parent() result: ${result}`);
                
                if (result && result !== '0x' && result !== '0x0000000000000000000000000000000000000000000000000000000000000000') {
                    const parentAddress = '0x' + result.slice(-40);
                    const normalizedParent = parentAddress.toLowerCase();
                    
                    if (normalizedParent !== '0x0000000000000000000000000000000000000000') {
                        console.log(`‚úÖ Found parent: ${parentAddress}`);
                        return parentAddress;
                    }
                }
                
                console.log(`‚ùå No valid parent found for ${address}`);
                return null;
                
            } catch (error) {
                console.log(`Parent lookup failed for ${address}: ${error.message}`);
                
                // Fallback selectors
                const fallbackSelectors = [
                    '0x60f96a8f', // lowercase parent()
                    '0x9dbbeb2b'  // another variant
                ];
                
                for (const selector of fallbackSelectors) {
                    try {
                        console.log(`Trying fallback selector: ${selector}`);
                        
                        const result = await makeRPCCall('eth_call', [
                            {
                                to: address,
                                data: selector
                            },
                            'latest'
                        ]);
                        
                        if (result && result !== '0x' && result !== '0x0000000000000000000000000000000000000000000000000000000000000000') {
                            const parentAddress = '0x' + result.slice(-40);
                            const normalizedParent = parentAddress.toLowerCase();
                            
                            if (normalizedParent !== '0x0000000000000000000000000000000000000000') {
                                console.log(`‚úÖ Found parent with fallback selector ${selector}: ${parentAddress}`);
                                return parentAddress;
                            }
                        }
                        
                    } catch (fallbackError) {
                        console.log(`Fallback selector ${selector} failed: ${fallbackError.message}`);
                    }
                }
                
                return null;
            }
        }

        // Toggle discovery log visibility
        function toggleDiscoveryLog() {
            const log = document.getElementById('discoveryLog');
            const btn = document.getElementById('logToggleBtn');
            
            if (log.style.display === 'none') {
                log.style.display = 'block';
                btn.textContent = 'üìÑ Hide Log';
                btn.title = 'Hide discovery log';
            } else {
                log.style.display = 'none';
                btn.textContent = 'üìÑ Show Log';
                btn.title = 'Show discovery log';
            }
        }

        // Test connection
        async function testConnection() {
            const testBtn = document.getElementById('testBtn');
            testBtn.disabled = true;
            testBtn.textContent = 'üîÑ Testing...';
            
            try {
                setStatus('Testing PulseChain connection...', 'loading');
                logDiscovery('Testing RPC connection...');
                
                const chainId = await makeRPCCall('eth_chainId');
                const blockNumber = await makeRPCCall('eth_blockNumber');
                
                const chainIdDecimal = parseInt(chainId, 16);
                const blockNumberDecimal = parseInt(blockNumber, 16);
                
                setStatus(`‚úÖ Connected! Chain ID: ${chainIdDecimal}, Block: ${blockNumberDecimal}`, 'connected');
                logDiscovery(`‚úÖ Connected to PulseChain! Block: ${blockNumberDecimal}`);
                testBtn.className = 'btn success';
                testBtn.textContent = '‚úÖ Connected';
                
                setTimeout(() => {
                    testBtn.className = 'btn';
                    testBtn.textContent = 'üîó Test Connection';
                }, 3000);
                
            } catch (error) {
                console.error('Connection test failed:', error);
                setStatus(`‚ùå Connection failed: ${error.message}`, 'error');
                logDiscovery(`‚ùå Connection failed: ${error.message}`);
                testBtn.textContent = '‚ùå Failed';
                
                setTimeout(() => {
                    testBtn.textContent = 'üîó Test Connection';
                }, 3000);
            } finally {
                testBtn.disabled = false;
            }
        }

        // Discover the entire token spine
        async function discoverSpine() {
            const discoverBtn = document.getElementById('discoverBtn');
            const startingAddress = document.getElementById('startingToken').value.trim();
            
            if (!startingAddress || !startingAddress.startsWith('0x')) {
                alert('Please enter a valid token address starting with 0x');
                return;
            }
            
            discoverBtn.disabled = true;
            discoverBtn.textContent = 'üß¨ Discovering...';
            
            try {
                setStatus('Discovering token spine...', 'loading');
                
                // Clear previous results
                discoveredTokens = [];
                document.getElementById('discoveryLog').textContent = 'Starting spine discovery...';
                
                logDiscovery(`Starting discovery from: ${startingAddress}`);
                
                // Test connection first
                await makeRPCCall('eth_chainId');
                
                let currentAddress = startingAddress.toLowerCase();
                let depth = 0;
                const maxDepth = 40;
                
                // Walk up the spine
                while (currentAddress && depth < maxDepth) {
                    logDiscovery(`Analyzing token ${depth + 1}: ${currentAddress}`);
                    
                    // Get token symbol
                    let tokenSymbol;
                    try {
                        console.log(`üöÄ About to call getTokenSymbol for ${currentAddress}`);
                        tokenSymbol = await getTokenSymbol(currentAddress);
                        console.log(`üéØ getTokenSymbol returned: ${tokenSymbol}`);
                    } catch (symbolError) {
                        console.error(`üí• getTokenSymbol threw error:`, symbolError);
                        tokenSymbol = `Token_${currentAddress.slice(-4)}`;
                    }
                    
                    logDiscovery(`  ‚Üí Symbol: ${tokenSymbol}`);
                    
                    // Get parent address
                    const parentAddress = await getParentToken(currentAddress);
                    
                    if (parentAddress) {
                        logDiscovery(`  ‚Üí Parent found: ${parentAddress}`);
                        discoveredTokens.unshift({
                            name: tokenSymbol,
                            address: currentAddress,
                            type: 'child'
                        });
                        currentAddress = parentAddress.toLowerCase();
                    } else {
                        logDiscovery(`  ‚Üí No parent found - this is the root token`);
                        discoveredTokens.unshift({
                            name: tokenSymbol,
                            address: currentAddress,
                            type: 'parent'
                        });
                        break;
                    }
                    
                    depth++;
                    
                    // Small delay to avoid overwhelming the RPC
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                if (depth >= maxDepth) {
                    logDiscovery(`‚ö†Ô∏è Reached maximum depth of ${maxDepth} tokens`);
                }
                
                logDiscovery(`\n‚úÖ Discovery complete! Found ${discoveredTokens.length} tokens in spine:`);
                discoveredTokens.forEach((token, i) => {
                    logDiscovery(`  ${i + 1}. ${token.name} (${token.type})`);
                });
                
                // Build the table
                buildTokenTable();
                
                // Enable refresh button
                document.getElementById('refreshBtn').disabled = false;
                
                setStatus(`‚úÖ Discovered ${discoveredTokens.length} tokens in spine!`, 'connected');
                
            } catch (error) {
                console.error('Discovery failed:', error);
                setStatus(`‚ùå Discovery failed: ${error.message}`, 'error');
                logDiscovery(`‚ùå Discovery failed: ${error.message}`);
            } finally {
                discoverBtn.disabled = false;
                discoverBtn.textContent = 'üß¨ Discover CC7 Spine';
            }
        }

        // Build token table from discovered tokens
        function buildTokenTable() {
            const tableBody = document.getElementById('tokenTable');
            tableBody.innerHTML = '';
            
            discoveredTokens.forEach((token, index) => {
                const row = document.createElement('tr');
                row.className = token.type === 'parent' ? 'parent-row' : 'child-row';
                row.id = `token-row-${index}`;
                
                row.innerHTML = `
                    <td>${token.type === 'parent' ? 'üèõÔ∏è Parent' : `üë∂ Child ${index}`}</td>
                    <td class="token-name">${token.name}</td>
                    <td class="address" onclick="copyAddress('${token.address}')" title="Click to copy">${token.address.substring(0, 6)}...${token.address.substring(token.address.length - 4)}</td>
                    <td class="loading-cell">Loading...</td>
                    <td class="loading-cell">${token.type === 'parent' ? 'N/A' : 'Reading...'}</td>
                    <td class="loading-cell">Loading...</td>
                    <td class="loading-cell">Loading...</td>
                    <td>${token.type === 'child' ? `<button class="mint-btn" onclick="openMintModal(${index})">Mint</button>` : 'N/A'}</td>
                `;
                
                tableBody.appendChild(row);
            });
        }

        function copyAddress(address) {
            navigator.clipboard.writeText(address);
        }

        // Utility functions
        function formatNumber(num) {
            if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
            if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
            if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';
            return num.toFixed(2);
        }

        // Refresh data for discovered tokens
        async function refreshData() {
            if (discoveredTokens.length === 0) {
                alert('No tokens discovered yet. Click "Discover CC7 Spine" first.');
                return;
            }
            
            const refreshBtn = document.getElementById('refreshBtn');
            refreshBtn.disabled = true;
            refreshBtn.textContent = 'üîÑ Loading...';
            
            try {
                setStatus('Loading token data with enhanced pricing...', 'loading');
                
                for (let i = 0; i < discoveredTokens.length; i++) {
                    const token = discoveredTokens[i];
                    const row = document.getElementById(`token-row-${i}`);
                    
                    if (!row) continue;
                    
                    const cells = row.children;
                    
                    try {
                        // Get token symbol for better naming
                        let tokenSymbol;
                        try {
                            tokenSymbol = await getTokenSymbol(token.address);
                            console.log(`üè∑Ô∏è Got symbol for ${token.name}: ${tokenSymbol}`);
                            token.name = tokenSymbol;
                            cells[1].textContent = tokenSymbol;
                        } catch (symbolError) {
                            console.log(`‚ö†Ô∏è Symbol lookup failed for ${token.name}: ${symbolError.message}`);
                        }
                        
                        // Get total supply
                        const totalSupplyResult = await makeRPCCall('eth_call', [
                            {
                                to: token.address,
                                data: '0x18160ddd' + '0'.repeat(56)
                            },
                            'latest'
                        ]);
                        
                        const totalSupply = parseInt(totalSupplyResult, 16) / Math.pow(10, 18);
                        
                        // Get multiplier for child tokens
                        let multiplier = null;
                        if (token.type === 'child') {
                            try {
                                const oneTokenInWei = '0x0de0b6b3a7640000';
                                const multiplierResult = await makeRPCCall('eth_call', [
                                    {
                                        to: token.address,
                                        data: '0x5677abcc' + oneTokenInWei.slice(2).padStart(64, '0')
                                    },
                                    'latest'
                                ]);
                                
                                multiplier = parseInt(multiplierResult, 16);
                                
                            } catch (e) {
                                multiplier = 1.0 + (i * 0.1);
                            }
                        }
                        
                        // Get price data with enhanced hierarchy
                        const priceData = await getPulseXPriceWithHierarchy(token.address);
                        
                        // Update cells
                        cells[3].textContent = formatNumber(totalSupply);
                        cells[3].className = '';
                        
                        if (token.type === 'child') {
                            cells[4].innerHTML = `<span class="multiplier">${multiplier}x</span>`;
                            cells[4].className = '';
                        }
                        
                        // Enhanced price display with source info
                        const formattedPrice = formatPrice(priceData.price);
                        cells[5].innerHTML = `${formattedPrice}<br><span class="price-source">${priceData.pairInfo || priceData.source}</span>`;
                        cells[5].className = priceData.priceChange24h >= 0 ? 'price' : 'price negative';
                        
                        const marketCap = totalSupply * priceData.price;
                        cells[6].textContent = `${formatNumber(marketCap)}`;
                        cells[6].className = '';
                        
                    } catch (error) {
                        console.error(`Error loading data for ${token.name}:`, error);
                        
                        // Fallback data
                        const addressNum = parseInt(token.address.slice(-4), 16);
                        const mockTotalSupply = (addressNum % 100000) * 10000;
                        const mockPrice = (addressNum % 1000) / 10 + Math.random() * 100;
                        
                        cells[3].textContent = formatNumber(mockTotalSupply);
                        if (token.type === 'child') {
                            cells[4].innerHTML = `<span class="multiplier">${Math.round(1.0 + i * 0.1)}x</span>`;
                        }
                        cells[5].textContent = `${mockPrice.toFixed(2)}`;
                        cells[5].className = 'price';
                        cells[6].textContent = `${formatNumber(mockTotalSupply * mockPrice)}`;
                    }
                    
                    // Small delay to avoid rate limiting
                    if (i < discoveredTokens.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                
                setStatus('Data loaded successfully with enhanced pricing!', 'connected');
                document.getElementById('lastUpdate').textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
                
            } catch (error) {
                console.error('Refresh failed:', error);
                setStatus(`‚ùå Refresh failed: ${error.message}`, 'error');
            } finally {
                refreshBtn.disabled = false;
                refreshBtn.textContent = 'üîÑ Refresh Data';
            }
        }

        // Auto-refresh toggle
        function toggleAutoRefresh() {
            const btn = document.getElementById('autoRefreshBtn');
            const interval = parseInt(document.getElementById('refreshInterval').value) * 1000;
            
            if (isAutoRefreshing) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                isAutoRefreshing = false;
                btn.textContent = '‚è∞ Auto-Refresh: OFF';
                btn.style.background = 'linear-gradient(45deg, #6a4c93, #9d4edd)';
            } else {
                if (discoveredTokens.length === 0) {
                    alert('Please discover a token spine first before enabling auto-refresh.');
                    return;
                }
                autoRefreshInterval = setInterval(refreshData, interval);
                isAutoRefreshing = true;
                btn.textContent = `‚è∞ Auto-Refresh: ON (${interval/1000}s)`;
                btn.style.background = 'linear-gradient(45deg, #27ae60, #2ecc71)';
            }
        }

        // MINT FUNCTIONS
        function openMintModal(tokenIndex) {
            const token = discoveredTokens[tokenIndex];
            if (!token) return;
            
            const parentToken = getParentTokenForMint(tokenIndex);
            const multiplier = getMultiplierForToken(tokenIndex);
            
            // Create URL parameters for the mint page
            const params = new URLSearchParams({
                childToken: token.address,
                childName: token.name,
                parentToken: parentToken.address,
                parentName: parentToken.name,
                multiplier: multiplier,
                tokenIndex: tokenIndex
            });
            
            // Open mint page in new tab
            window.open(`mint.html?${params.toString()}`, '_blank');
        }
        
        function getParentTokenForMint(tokenIndex) {
            if (tokenIndex === 0) {
                return {
                    address: "0x0000000000000000000000000000000000000000",
                    name: "Root Token"
                };
            }
            const parentToken = discoveredTokens[tokenIndex - 1];
            return {
                address: parentToken?.address || "0x0000000000000000000000000000000000000000",
                name: parentToken?.name || "Unknown Parent"
            };
        }
        
        function getMultiplierForToken(tokenIndex) {
            // Try to get multiplier from the table cell
            const row = document.getElementById(`token-row-${tokenIndex}`);
            if (row) {
                const multiplierCell = row.children[4]; // Multiplier is 5th column (index 4)
                const multiplierSpan = multiplierCell.querySelector('.multiplier');
                if (multiplierSpan) {
                    return multiplierSpan.textContent.replace('x', '');
                }
            }
            return '1.0'; // Default multiplier
        }

        // Initialize on load
        window.onload = function() {
            console.log('üß¨ Enhanced Dynamic Spine Token Tracker Loading...');
            
            // Auto-test connection after a short delay
            setTimeout(testConnection, 1000);
        };

        // Cleanup
        window.addEventListener('beforeunload', function() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }
        });

        // Global functions for console debugging
        window.DynamicTracker = {
            discoverSpine,
            refreshData,
            testConnection,
            makeRPCCall,
            getParentToken,
            getTokenSymbol,
            getPulseXPriceWithHierarchy,
            discoveredTokens: () => discoveredTokens,
            priceCache: () => priceCache,
            debugDiscovery: async function(address) {
                console.log('=== DEBUGGING TOKEN DISCOVERY ===');
                console.log(`Starting from: ${address}`);
                
                try {
                    const symbol = await getTokenSymbol(address);
                    console.log(`Token symbol: ${symbol}`);
                    
                    const parent = await getParentToken(address);
                    console.log(`Parent token: ${parent || 'None (this is root)'}`);
                    
                    if (parent) {
                        const parentSymbol = await getTokenSymbol(parent);
                        console.log(`Parent symbol: ${parentSymbol}`);
                    }
                    
                    const priceData = await getPulseXPriceWithHierarchy(address);
                    console.log(`Price data:`, priceData);
                    
                } catch (error) {
                    console.error('Debug failed:', error);
                }
            }
        };

        console.log('üöÄ Enhanced Dynamic Spine Token Tracker loaded!');
        console.log('üéØ Enhanced with PLS-first pricing hierarchy!');
        console.log('Try DynamicTracker.debugDiscovery("0x...") to test discovery on any token');
        console.log('Example: DynamicTracker.debugDiscovery("0xea4ff5498882b63b1c4a6c9f6f43c219beaf9628")');
    </script>
</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Spine Token Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            padding: 20px;
            color: #e0e0e0;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(20, 20, 40, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(157, 78, 221, 0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #ffffff;
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #9d4edd, #6a4c93, #3a86ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(157, 78, 221, 0.3);
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .btn {
            background: linear-gradient(45deg, #6a4c93, #9d4edd);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(157, 78, 221, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(157, 78, 221, 0.4);
            background: linear-gradient(45deg, #9d4edd, #3a86ff);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn.success {
            background: linear-gradient(45deg, #06ffa5, #00cc88);
            box-shadow: 0 4px 15px rgba(6, 255, 165, 0.3);
        }
        
        .btn.discover {
            background: linear-gradient(45deg, #3a86ff, #06ffa5);
            box-shadow: 0 4px 15px rgba(58, 134, 255, 0.3);
        }
        
        .status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .status.connected {
            background: rgba(6, 255, 165, 0.2);
            color: #06ffa5;
            border: 1px solid rgba(6, 255, 165, 0.3);
        }
        
        .status.error {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }
        
        .status.loading {
            background: rgba(157, 78, 221, 0.2);
            color: #9d4edd;
            border: 1px solid rgba(157, 78, 221, 0.3);
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .config-section {
            background: rgba(102, 126, 234, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 25px;
            border: 2px solid rgba(102, 126, 234, 0.2);
        }
        
        .config-title {
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }
        
        .config-item {
            display: inline-block;
            margin-right: 20px;
            margin-bottom: 10px;
        }
        
        .config-item label {
            font-size: 0.9rem;
            color: #c0c0c0;
            font-weight: 500;
            margin-right: 10px;
        }
        
        .config-item input {
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            font-size: 0.9rem;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            width: 400px;
        }
        
        .config-item input::placeholder {
            color: #888;
        }
        
        .discovery-log {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #c0c0c0;
        }
        
        .table-container {
            overflow-x: auto;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(30, 30, 60, 0.8);
            font-size: 0.85rem;
            border-radius: 15px;
            overflow: hidden;
        }
        
        th {
            background: linear-gradient(45deg, #6a4c93, #9d4edd);
            color: white;
            padding: 12px 8px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            font-size: 0.8rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        td {
            padding: 10px 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background-color 0.3s ease;
            color: #e0e0e0;
        }
        
        tr:hover {
            background-color: rgba(157, 78, 221, 0.1);
        }
        
        .parent-row {
            background: rgba(6, 255, 165, 0.2);
            border-left: 4px solid #06ffa5;
            font-weight: 600;
        }
        
        .child-row {
            background: rgba(157, 78, 221, 0.1);
            border-left: 4px solid #9d4edd;
        }
        
        .token-name {
            font-weight: 600;
            color: #ffffff;
        }
        
        .address {
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            color: #90a4ae;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        
        .address:hover {
            color: #9d4edd;
        }
        
        .price {
            font-weight: 600;
            color: #06ffa5;
            font-family: 'Courier New', monospace;
            text-align: right;
        }
        
        .price.negative {
            color: #f44336;
        }
        
        .multiplier {
            background: linear-gradient(45deg, #3a86ff, #6a4c93);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: 600;
            text-align: right;
            min-width: 60px;
            font-size: 0.8rem;
            font-family: 'Courier New', monospace;
            box-shadow: 0 2px 8px rgba(58, 134, 255, 0.3);
            display: inline-block;
        }
        
        .loading-cell {
            text-align: center;
            color: #90a4ae;
            font-style: italic;
        }
        
        .price-source {
            font-size: 0.7rem;
            color: #888;
            font-style: italic;
        }
        
        .mint-btn {
            background: linear-gradient(45deg, #3a86ff, #06ffa5);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(58, 134, 255, 0.3);
        }
        
        .mint-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(58, 134, 255, 0.4);
        }
        
        .mint-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        
        .mint-modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.98);
            border-radius: 20px;
            padding: 30px;
            width: 90%;
            max-width: 500px;
            border: 2px solid rgba(157, 78, 221, 0.3);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }
        
        .mint-modal h3 {
            color: #ffffff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            text-align: center;
            background: linear-gradient(45deg, #9d4edd, #3a86ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .wallet-section {
            background: rgba(102, 126, 234, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 2px solid rgba(102, 126, 234, 0.2);
            text-align: center;
        }
        
        .wallet-btn {
            background: linear-gradient(45deg, #3a86ff, #06ffa5);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(58, 134, 255, 0.3);
            margin: 10px;
        }
        
        .wallet-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(58, 134, 255, 0.4);
        }
        
        .wallet-connected {
            background: rgba(6, 255, 165, 0.2);
            color: #06ffa5;
            border: 1px solid rgba(6, 255, 165, 0.3);
            padding: 12px 20px;
            border-radius: 15px;
            font-size: 1rem;
            font-weight: 500;
        }
        
        .step-indicator {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .step {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            margin: 0 5px;
            transition: all 0.3s ease;
        }
        
        .step.active {
            background: linear-gradient(45deg, #3a86ff, #06ffa5);
            color: white;
        }
        
        .step.inactive {
            background: rgba(255, 255, 255, 0.1);
            color: #888;
        }
        
        .step-line {
            width: 40px;
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            margin: 0 10px;
        }
        
        .step-line.active {
            background: linear-gradient(45deg, #3a86ff, #06ffa5);
        }
        
        .step-text {
            text-align: center;
            color: #c0c0c0;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            color: #ffffff;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .form-group input {
            width: 100%;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            font-size: 0.9rem;
        }
        
        .form-group input:focus {
            outline: none;
            border-color: #3a86ff;
            box-shadow: 0 0 10px rgba(58, 134, 255, 0.3);
        }
        
        .form-group input[readonly] {
            background: rgba(255, 255, 255, 0.05);
            color: #c0c0c0;
        }
        
        .mint-note {
            font-size: 0.8rem;
            color: #888;
            margin-top: 5px;
            font-style: italic;
        }
        
        .modal-buttons {
            display: flex;
            gap: 15px;
            margin-top: 25px;
        }
        
        .modal-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .modal-btn.primary {
            background: linear-gradient(45deg, #3a86ff, #06ffa5);
            color: white;
        }
        
        .modal-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #c0c0c0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .modal-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .modal-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .close-btn {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        
        .close-btn:hover {
            color: #ffffff;
        }
        
        .footer {
            text-align: center;
            margin-top: 30px;
            color: #90a4ae;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            table {
                font-size: 0.75rem;
            }
            
            th, td {
                padding: 6px 4px;
            }
            
            .mint-modal-content {
                padding: 20px;
                width: 95%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Dynamic Spine Token Tracker</h1>
            <p>Automatically discover CC7 factory token spines by walking up from any child token</p>
            <div style="background: rgba(157, 78, 221, 0.1); padding: 15px; border-radius: 10px; margin-top: 15px; border: 2px solid rgba(157, 78, 221, 0.2);">
                <strong>‚ö†Ô∏è Entertainment Purposes Only:</strong> This tool is for entertainment purposes. All data should be independently verified before making any financial decisions. Always DYOR (Do Your Own Research).
            </div>
        </div>
        
        <div class="config-section">
            <div class="config-title">
                üîß Configuration
                <button onclick="toggleDiscoveryLog()" id="logToggleBtn" style="float: right; background: rgba(157, 78, 221, 0.3); border: 1px solid rgba(157, 78, 221, 0.5); color: #9d4edd; padding: 4px 8px; border-radius: 6px; font-size: 0.8rem; cursor: pointer;">
                    üìÑ Hide Log
                </button>
            </div>
            <div class="config-item">
                <label>RPC URL:</label>
                <input type="text" id="rpcUrl" value="https://rpc-pulsechain.g4mm4.io">
            </div>
            <div class="config-item">
                <label>Starting CC7 Token Address (lowest child):</label>
                <input type="text" id="startingToken" value="0xea4ff5498882b63b1c4a6c9f6f43c219beaf9628" placeholder="0x...">
            </div>
            <div class="config-item">
                <label>Auto-refresh interval (seconds):</label>
                <input type="number" id="refreshInterval" value="300" min="10" max="600" style="width: 100px;">
            </div>
            
            <div class="discovery-log" id="discoveryLog" style="max-height: 100px;">
                Ready to discover CC7 token spine... Enter a CC7 child token address and click "Discover CC7 Spine"
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <button class="btn" onclick="testConnection()" id="testBtn">
                    üîó Test Connection
                </button>
                <button class="btn discover" onclick="discoverSpine()" id="discoverBtn">
                    üß¨ Discover CC7 Spine
                </button>
                <button class="btn" onclick="refreshData()" id="refreshBtn" disabled>
                    üîÑ Refresh Data
                </button>
                <button class="btn" onclick="toggleAutoRefresh()" id="autoRefreshBtn">
                    ‚è∞ Auto-Refresh: OFF
                </button>
            </div>
            
            <div class="control-group">
                <div class="status" id="status">
                    <div class="status-dot"></div>
                    <span>Ready to connect</span>
                </div>
                <div style="font-size: 0.8rem; color: #90a4ae;" id="lastUpdate">
                    Last updated: Never
                </div>
            </div>
        </div>
        
        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Position</th>
                        <th>Token Name</th>
                        <th>Contract Address</th>
                        <th>Total Supply</th>
                        <th>Multiplier</th>
                        <th>Price (USD)</th>
                        <th>Market Cap</th>
                        <th style="width: 60px;">Mint</th>
                    </tr>
                </thead>
                <tbody id="tokenTable">
                    <tr>
                        <td colspan="8" style="text-align: center; padding: 40px; color: #90a4ae;">
                            No CC7 tokens discovered yet. Click "Discover CC7 Spine" to start building the spine from a CC7 child token.
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="footer">
            <p><strong>Instructions:</strong> 1) Enter any CC7 child token address ‚Üí 2) Click "Discover CC7 Spine" ‚Üí 3) Click "Refresh Data" to load prices/multipliers</p>
            <p><strong>Price Colors:</strong> Green = 24h price increase, Red = 24h price decrease</p>
            <p><strong>Enhanced Pricing:</strong> Prioritizes PLS pairs ‚Üí USDC/USDT ‚Üí ETH pairs for maximum accuracy</p>
            <p><strong>Note:</strong> This tool only works with tokens created from the CC7 factory. Please avoid using auto-refresh to limit RPC calls and be respectful of the infrastructure</p>
            <p><strong>Chain:</strong> PulseChain (Chain ID: 369) | <strong>RPC:</strong> G4mm4.io</p>
            
            <div style="margin-top: 30px; padding: 20px; background: rgba(157, 78, 221, 0.1); border-radius: 15px; border: 2px solid rgba(157, 78, 221, 0.2); text-align: left;">
                <p style="margin-bottom: 15px;">The provided information may not be 100% accurate and still needs some testing.</p>
                <p style="margin-bottom: 10px;"><strong>Your support is greatly appreciated and helps me continue improving the website.</strong></p>
                <p style="font-family: 'Courier New', monospace; background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 8px; margin: 10px 0; word-break: break-all; font-size: 0.85rem;">0x809b15CCdC92882035C274738318296525b98aD8</p>
                
                <p style="margin-top: 20px; margin-bottom: 10px;"><strong>Disclaimer:</strong></p>
                <p style="margin-bottom: 10px; font-size: 0.9rem; line-height: 1.4;">All content provided on this site is for informational purposes only and does not constitute financial advice. None of the information presented here should be considered as investment advice or a recommendation to buy, sell, or hold any financial product or instrument.</p>
                
                <p style="margin-bottom: 10px; font-size: 0.9rem; line-height: 1.4;">Please perform your own research and consult with a qualified financial advisor before making any investment decisions. We do not take responsibility for any financial losses you may incur as a result of using the information provided on this site.</p>
                
                <p style="margin-bottom: 0; font-size: 0.9rem; line-height: 1.4;">Remember, all investments carry risk, and past performance is not indicative of future results.</p>
            </div>
        </div>
    </div>

    <script>
        let discoveredTokens = [];
        let autoRefreshInterval = null;
        let isAutoRefreshing = false;
        let isWalletConnected = false;
        let walletAccount = null;
        let currentMintStep = 1;
        let selectedTokenData = null;
        const priceCache = new Map();
        const CACHE_DURATION = 60000;

        async function makeRPCCall(method, params = []) {
            const rpcUrl = document.getElementById('rpcUrl').value;
            const response = await fetch(rpcUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    method: method,
                    params: params,
                    id: Date.now()
                })
            });
            if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            const data = await response.json();
            if (data.error) throw new Error(`RPC Error: ${data.error.message}`);
            return data.result;
        }

        function setStatus(message, type = 'loading') {
            const status = document.getElementById('status');
            status.className = `status ${type}`;
            status.querySelector('span').textContent = message;
        }

        function logDiscovery(message) {
            const log = document.getElementById('discoveryLog');
            const timestamp = new Date().toLocaleTimeString();
            log.textContent += `\n[${timestamp}] ${message}`;
            log.scrollTop = log.scrollHeight;
        }

        function formatPrice(price) {
            if (price < 1) {
                return price.toFixed(5);
            } else {
                return price.toLocaleString('en-US', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            }
        }

        function hexToString(hex) {
            let result = '';
            for (let i = 0; i < hex.length; i += 2) {
                const byte = parseInt(hex.substr(i, 2), 16);
                if (byte !== 0) {
                    result += String.fromCharCode(byte);
                }
            }
            return result.replace(/[^\x20-\x7E]/g, '');
        }

        async function getTokenSymbol(address) {
            console.log(`üîç getTokenSymbol called for ${address}`);
            
            try {
                console.log(`üîç Getting symbol from contract for ${address}...`);
                
                const symbolResult = await makeRPCCall('eth_call', [
                    {
                        to: address,
                        data: '0x95d89b41'
                    },
                    'latest'
                ]);
                
                console.log(`üì• Symbol result for ${address}: ${symbolResult}`);
                
                if (symbolResult && symbolResult !== '0x') {
                    const hex = symbolResult.slice(2);
                    console.log(`üî§ Processing hex: ${hex}`);
                    
                    if (hex.length >= 64) {
                        // Try different decoding approaches
                        
                        // Approach 1: Standard ABI encoding
                        if (hex.length >= 128) {
                            try {
                                console.log(`üß™ Trying standard ABI decoding...`);
                                const lengthHex = hex.substring(64, 128);
                                const length = parseInt(lengthHex, 16);
                                console.log(`üìê Decoded length: ${length}`);
                                if (length > 0 && length < 100) {
                                    const symbolHex = hex.substring(128, 128 + (length * 2));
                                    console.log(`üî§ Symbol hex: ${symbolHex}`);
                                    const symbol = hexToString(symbolHex);
                                    console.log(`‚ú® Decoded symbol: "${symbol}"`);
                                    if (symbol && symbol.length > 0 && /^[A-Za-z0-9]+$/.test(symbol)) {
                                        console.log(`‚úÖ Symbol decoded (standard): ${symbol}`);
                                        return symbol;
                                    }
                                }
                            } catch (e) {
                                console.log('‚ùå Standard ABI decoding failed:', e.message);
                            }
                        }
                        
                        // Approach 2: Direct hex to string
                        try {
                            console.log(`üß™ Trying direct hex decoding...`);
                            const cleanHex = hex.replace(/^0+/, '');
                            console.log(`üßπ Clean hex: ${cleanHex}`);
                            if (cleanHex.length > 0 && cleanHex.length <= 64) {
                                const directSymbol = hexToString(cleanHex);
                                console.log(`‚ú® Direct decoded: "${directSymbol}"`);
                                if (directSymbol && /^[A-Za-z0-9]+$/.test(directSymbol) && directSymbol.length <= 10) {
                                    console.log(`‚úÖ Symbol decoded (direct): ${directSymbol}`);
                                    return directSymbol;
                                }
                            }
                        } catch (e) {
                            console.log('‚ùå Direct hex decoding failed:', e.message);
                        }
                        
                        // Approach 3: Try last 32 bytes
                        try {
                            console.log(`üß™ Trying last part decoding...`);
                            const lastPart = hex.slice(-64);
                            console.log(`üîö Last part: ${lastPart}`);
                            const lastSymbol = hexToString(lastPart);
                            console.log(`‚ú® Last decoded: "${lastSymbol}"`);
                            if (lastSymbol && /^[A-Za-z0-9]+$/.test(lastSymbol) && lastSymbol.length <= 10) {
                                console.log(`‚úÖ Symbol decoded (last part): ${lastSymbol}`);
                                return lastSymbol;
                            }
                        } catch (e) {
                            console.log('‚ùå Last part decoding failed:', e.message);
                        }
                        
                        // Approach 4: Try the entire hex as a single string
                        try {
                            console.log(`üß™ Trying full hex as string...`);
                            const fullSymbol = hexToString(hex).trim();
                            console.log(`‚ú® Full decoded: "${fullSymbol}"`);
                            if (fullSymbol && /^[A-Za-z0-9]+$/.test(fullSymbol) && fullSymbol.length <= 20) {
                                console.log(`‚úÖ Symbol decoded (full): ${fullSymbol}`);
                                return fullSymbol;
                            }
                        } catch (e) {
                            console.log('‚ùå Full hex decoding failed:', e.message);
                        }
                    } else {
                        console.log(`‚ö†Ô∏è Hex too short: ${hex.length} characters`);
                    }
                } else {
                    console.log(`‚ö†Ô∏è Empty or null symbol result`);
                }
                
                console.log(`‚ö†Ô∏è Contract symbol lookup failed, trying Gecko Terminal...`);
                
            } catch (error) {
                console.log(`üí• Contract symbol lookup failed for ${address}: ${error.message}`);
            }
            
            // Fallback to Gecko Terminal API
            try {
                const geckoSymbol = await getTokenNameFromGecko(address);
                if (geckoSymbol) {
                    return geckoSymbol;
                }
            } catch (geckoError) {
                console.log(`üí• Gecko lookup also failed: ${geckoError.message}`);
            }
            
            // Final fallback to address-based name
            console.log(`‚ùå All symbol lookups failed for ${address}, using fallback`);
            return `Token_${address.slice(-4)}`;
        }

        // Get token name/symbol from Gecko Terminal API
        async function getTokenNameFromGecko(address) {
            try {
                const pulseChainId = 'pulsechain';
                const url = `https://api.geckoterminal.com/api/v2/networks/${pulseChainId}/tokens/${address.toLowerCase()}`;
                
                console.log(`ü¶é Fetching token info from Gecko for ${address}...`);
                
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Gecko API: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.data && data.data.attributes) {
                    const attrs = data.data.attributes;
                    const symbol = attrs.symbol || attrs.name;
                    if (symbol) {
                        console.log(`‚úÖ Got symbol from Gecko: ${symbol}`);
                        return symbol;
                    }
                }
                
                throw new Error('No symbol/name in Gecko response');
                
            } catch (error) {
                console.log(`‚ùå Gecko lookup failed for ${address}: ${error.message}`);
                return null;
            }
        }

        async function getMultiplier(address) {
            try {
                // Call the multiplier() function on the CC7 token contract
                const result = await makeRPCCall('eth_call', [
                    { to: address, data: '0x1f4e1504' }, // multiplier() selector
                    'latest'
                ]);
                
                if (result && result !== '0x') {
                    // Decode the result - it should be a uint256 representing the multiplier in wei
                    const multiplierWei = parseInt(result, 16);
                    const multiplier = multiplierWei / Math.pow(10, 18); // Convert from wei to ether
                    return multiplier;
                }
                return 1.0; // Default multiplier if call fails
            } catch (error) {
                console.log(`‚ùå Failed to get multiplier for ${address}: ${error.message}`);
                return 1.0; // Default multiplier
            }
        }
            try {
                const result = await makeRPCCall('eth_call', [
                    { to: address, data: '0xd3c8dd69' },
                    'latest'
                ]);
                
                if (result && result !== '0x' && result !== '0x0000000000000000000000000000000000000000000000000000000000000000') {
                    const parentAddress = '0x' + result.slice(-40);
                    if (parentAddress.toLowerCase() !== '0x0000000000000000000000000000000000000000') {
                        return parentAddress;
                    }
                }
                return null;
            } catch (error) {
                return null;
            }
        }

        function toggleDiscoveryLog() {
            const log = document.getElementById('discoveryLog');
            const btn = document.getElementById('logToggleBtn');
            if (log.style.display === 'none') {
                log.style.display = 'block';
                btn.textContent = 'üìÑ Hide Log';
            } else {
                log.style.display = 'none';
                btn.textContent = 'üìÑ Show Log';
            }
        }

        async function testConnection() {
            const testBtn = document.getElementById('testBtn');
            testBtn.disabled = true;
            testBtn.textContent = 'üîÑ Testing...';
            
            try {
                setStatus('Testing PulseChain connection...', 'loading');
                logDiscovery('Testing RPC connection...');
                
                const chainId = await makeRPCCall('eth_chainId');
                const blockNumber = await makeRPCCall('eth_blockNumber');
                
                const chainIdDecimal = parseInt(chainId, 16);
                const blockNumberDecimal = parseInt(blockNumber, 16);
                
                setStatus(`‚úÖ Connected! Chain ID: ${chainIdDecimal}, Block: ${blockNumberDecimal}`, 'connected');
                logDiscovery(`‚úÖ Connected to PulseChain! Block: ${blockNumberDecimal}`);
                testBtn.className = 'btn success';
                testBtn.textContent = '‚úÖ Connected';
                
                setTimeout(() => {
                    testBtn.className = 'btn';
                    testBtn.textContent = 'üîó Test Connection';
                }, 3000);
                
            } catch (error) {
                setStatus(`‚ùå Connection failed: ${error.message}`, 'error');
                logDiscovery(`‚ùå Connection failed: ${error.message}`);
                testBtn.textContent = '‚ùå Failed';
                setTimeout(() => { testBtn.textContent = 'üîó Test Connection'; }, 3000);
            } finally {
                testBtn.disabled = false;
            }
        }

        async function discoverSpine() {
            const discoverBtn = document.getElementById('discoverBtn');
            const startingAddress = document.getElementById('startingToken').value.trim();
            
            if (!startingAddress || !startingAddress.startsWith('0x')) {
                alert('Please enter a valid token address starting with 0x');
                return;
            }
            
            discoverBtn.disabled = true;
            discoverBtn.textContent = 'üß¨ Discovering...';
            
            try {
                setStatus('Discovering token spine...', 'loading');
                discoveredTokens = [];
                document.getElementById('discoveryLog').textContent = 'Starting spine discovery...';
                logDiscovery(`Starting discovery from: ${startingAddress}`);
                
                await makeRPCCall('eth_chainId');
                
                let currentAddress = startingAddress.toLowerCase();
                let depth = 0;
                const maxDepth = 40;
                
                while (currentAddress && depth < maxDepth) {
                    logDiscovery(`Analyzing token ${depth + 1}: ${currentAddress}`);
                    
                    let tokenSymbol;
                    try {
                        tokenSymbol = await getTokenSymbol(currentAddress);
                    } catch (symbolError) {
                        tokenSymbol = `Token_${currentAddress.slice(-4)}`;
                    }
                    
                    logDiscovery(`  ‚Üí Symbol: ${tokenSymbol}`);
                    
                    const parentAddress = await getParentToken(currentAddress);
                    
                    if (parentAddress) {
                        logDiscovery(`  ‚Üí Parent found: ${parentAddress}`);
                        discoveredTokens.unshift({
                            name: tokenSymbol,
                            address: currentAddress,
                            type: 'child'
                        });
                        currentAddress = parentAddress.toLowerCase();
                    } else {
                        logDiscovery(`  ‚Üí No parent found - this is the root token`);
                        discoveredTokens.unshift({
                            name: tokenSymbol,
                            address: currentAddress,
                            type: 'parent'
                        });
                        break;
                    }
                    
                    depth++;
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                if (depth >= maxDepth) {
                    logDiscovery(`‚ö†Ô∏è Reached maximum depth of ${maxDepth} tokens`);
                }
                
                logDiscovery(`\n‚úÖ Discovery complete! Found ${discoveredTokens.length} tokens in spine`);
                buildTokenTable();
                document.getElementById('refreshBtn').disabled = false;
                setStatus(`‚úÖ Discovered ${discoveredTokens.length} tokens in spine!`, 'connected');
                
            } catch (error) {
                setStatus(`‚ùå Discovery failed: ${error.message}`, 'error');
                logDiscovery(`‚ùå Discovery failed: ${error.message}`);
            } finally {
                discoverBtn.disabled = false;
                discoverBtn.textContent = 'üß¨ Discover CC7 Spine';
            }
        }

        function buildTokenTable() {
            const tableBody = document.getElementById('tokenTable');
            tableBody.innerHTML = '';
            
            discoveredTokens.forEach((token, index) => {
                const row = document.createElement('tr');
                row.className = token.type === 'parent' ? 'parent-row' : 'child-row';
                row.id = `token-row-${index}`;
                
                row.innerHTML = `
                    <td>${token.type === 'parent' ? 'üèõÔ∏è Parent' : `üë∂ Child ${index}`}</td>
                    <td class="token-name">${token.name}</td>
                    <td class="address" onclick="copyAddress('${token.address}')" title="Click to copy">${token.address.substring(0, 6)}...${token.address.substring(token.address.length - 4)}</td>
                    <td class="loading-cell">Loading...</td>
                    <td class="loading-cell">${token.type === 'parent' ? 'N/A' : 'Reading...'}</td>
                    <td class="loading-cell">Loading...</td>
                    <td class="loading-cell">Loading...</td>
                    <td>${token.type === 'child' ? `<button class="mint-btn" onclick="openMintModal(${index})">Mint</button>` : 'N/A'}</td>
                `;
                
                tableBody.appendChild(row);
            });
        }

        function copyAddress(address) {
            navigator.clipboard.writeText(address);
        }

        function formatNumber(num) {
            if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
            if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
            if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';
            return num.toFixed(2);
        }

        async function refreshData() {
            if (discoveredTokens.length === 0) {
                alert('No tokens discovered yet. Click "Discover CC7 Spine" first.');
                return;
            }
            
            const refreshBtn = document.getElementById('refreshBtn');
            refreshBtn.disabled = true;
            refreshBtn.textContent = 'üîÑ Loading...';
            
            try {
                setStatus('Loading token data...', 'loading');
                
                for (let i = 0; i < discoveredTokens.length; i++) {
                    const token = discoveredTokens[i];
                    const row = document.getElementById(`token-row-${i}`);
                    if (!row) continue;
                    
                    const cells = row.children;
                    
                    try {
                        // Get total supply
                        const totalSupplyResult = await makeRPCCall('eth_call', [
                            { to: token.address, data: '0x18160ddd' + '0'.repeat(56) },
                            'latest'
                        ]);
                        
                        const totalSupply = parseInt(totalSupplyResult, 16) / Math.pow(10, 18);
                        
                        // Mock price data for demo
                        const addressNum = parseInt(token.address.slice(-4), 16);
                        const mockPrice = (addressNum % 1000) / 1000000 + Math.random() * 0.0001;
                        
                        cells[3].textContent = formatNumber(totalSupply);
                        cells[3].className = '';
                        
                        cells[5].textContent = `${formatPrice(mockPrice)}`;
                        cells[5].className = 'price';
                        
                        const marketCap = totalSupply * mockPrice;
                        cells[6].textContent = `${formatNumber(marketCap)}`;
                        cells[6].className = '';
                        
                        // Get multiplier for child tokens
                        if (token.type === 'child') {
                            try {
                                const multiplier = await getMultiplier(token.address);
                                cells[4].innerHTML = `<span class="multiplier">${multiplier.toFixed(1)}x</span>`;
                                cells[4].className = '';
                            } catch (multiplierError) {
                                console.log(`‚ö†Ô∏è Failed to get multiplier for ${token.address}:`, multiplierError);
                                cells[4].innerHTML = `<span class="multiplier">1.0x</span>`;
                                cells[4].className = '';
                            }
                        }
                        
                    } catch (error) {
                        // Fallback data
                        const addressNum = parseInt(token.address.slice(-4), 16);
                        const mockTotalSupply = (addressNum % 100000) * 10000;
                        const mockPrice = (addressNum % 1000) / 1000000;
                        
                        cells[3].textContent = formatNumber(mockTotalSupply);
                        cells[5].textContent = `${formatPrice(mockPrice)}`;
                        cells[5].className = 'price';
                        cells[6].textContent = `${formatNumber(mockTotalSupply * mockPrice)}`;
                        
                        if (token.type === 'child') {
                            // Try to get real multiplier even in fallback
                            getMultiplier(token.address).then(multiplier => {
                                cells[4].innerHTML = `<span class="multiplier">${multiplier.toFixed(1)}x</span>`;
                            }).catch(() => {
                                cells[4].innerHTML = `<span class="multiplier">1.0x</span>`;
                            });
                        }
                    }
                    
                    if (i < discoveredTokens.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                
                setStatus('Data loaded successfully!', 'connected');
                document.getElementById('lastUpdate').textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
                
            } catch (error) {
                setStatus(`‚ùå Refresh failed: ${error.message}`, 'error');
            } finally {
                refreshBtn.disabled = false;
                refreshBtn.textContent = 'üîÑ Refresh Data';
            }
        }

        function toggleAutoRefresh() {
            const btn = document.getElementById('autoRefreshBtn');
            const interval = parseInt(document.getElementById('refreshInterval').value) * 1000;
            
            if (isAutoRefreshing) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                isAutoRefreshing = false;
                btn.textContent = '‚è∞ Auto-Refresh: OFF';
                btn.style.background = 'linear-gradient(45deg, #6a4c93, #9d4edd)';
            } else {
                if (discoveredTokens.length === 0) {
                    alert('Please discover a token spine first before enabling auto-refresh.');
                    return;
                }
                autoRefreshInterval = setInterval(refreshData, interval);
                isAutoRefreshing = true;
                btn.textContent = `‚è∞ Auto-Refresh: ON (${interval/1000}s)`;
                btn.style.background = 'linear-gradient(45deg, #27ae60, #2ecc71)';
            }
        }

        // MINT FUNCTIONS
        function openMintModal(tokenIndex) {
            const token = discoveredTokens[tokenIndex];
            if (!token) return;
            
            const parentAddress = getParentAddressForToken(tokenIndex);
            
            // Create URL parameters for the mint page
            const params = new URLSearchParams({
                childToken: token.address,
                childName: token.name,
                parentToken: parentAddress,
                tokenIndex: tokenIndex
            });
            
            // Open mint page in new tab
            window.open(`mint.html?${params.toString()}`, '_blank');
        }
        
        function getParentAddressForToken(tokenIndex) {
            if (tokenIndex === 0) {
                return "0x0000000000000000000000000000000000000000";
            }
            return discoveredTokens[tokenIndex - 1]?.address || "0x0000000000000000000000000000000000000000";
        }

        // Initialize on load
        window.onload = function() {
            setTimeout(testConnection, 1000);
        };

        window.addEventListener('beforeunload', function() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }
        });
    </script>
</body>
</html>